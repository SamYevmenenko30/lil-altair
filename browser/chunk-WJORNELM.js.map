{"version":3,"sources":["../../node_modules/.pnpm/graphql-sse@2.5.3_graphql@15.5.1/node_modules/graphql-sse/lib/utils.mjs","../../node_modules/.pnpm/graphql-sse@2.5.3_graphql@15.5.1/node_modules/graphql-sse/lib/common.mjs","../../node_modules/.pnpm/graphql-sse@2.5.3_graphql@15.5.1/node_modules/graphql-sse/lib/parser.mjs","../../node_modules/.pnpm/graphql-sse@2.5.3_graphql@15.5.1/node_modules/graphql-sse/lib/client.mjs","../altair-core/src/request/handlers/sse.ts"],"sourcesContent":["/**\n *\n * utils\n *\n */\n/** @private */\nexport function isObject(val) {\n  return typeof val === 'object' && val !== null;\n}","/**\n *\n * common\n *\n */\nimport { isObject } from './utils.mjs';\n/**\n * Header key through which the event stream token is transmitted\n * when using the client in \"single connection mode\".\n *\n * Read more: https://github.com/enisdenjo/graphql-sse/blob/master/PROTOCOL.md#single-connection-mode\n *\n * @category Common\n */\nexport const TOKEN_HEADER_KEY = 'x-graphql-event-stream-token';\n/**\n * URL query parameter key through which the event stream token is transmitted\n * when using the client in \"single connection mode\".\n *\n * Read more: https://github.com/enisdenjo/graphql-sse/blob/master/PROTOCOL.md#single-connection-mode\n *\n * @category Common\n */\nexport const TOKEN_QUERY_KEY = 'token';\n/** @category Common */\nexport function validateStreamEvent(e) {\n  e = e;\n  if (e !== 'next' && e !== 'complete') throw new Error(`Invalid stream event \"${e}\"`);\n  return e;\n}\n/** @category Common */\nexport function print(msg) {\n  let str = `event: ${msg.event}\\ndata:`;\n  if (msg.data) {\n    str += ' ';\n    str += JSON.stringify(msg.data);\n  }\n  str += '\\n\\n';\n  return str;\n}\n/** @category Common */\nexport function parseStreamData(e, data) {\n  if (data) {\n    try {\n      data = JSON.parse(data);\n    } catch {\n      throw new Error('Invalid stream data');\n    }\n  }\n  if (e === 'next' && !data) throw new Error('Stream data must be an object for \"next\" events');\n  return data || null;\n}\n/**\n * Checkes whether the provided value is an async iterable.\n *\n * @category Common\n */\nexport function isAsyncIterable(val) {\n  return typeof Object(val)[Symbol.asyncIterator] === 'function';\n}\n/**\n * Checkes whether the provided value is an async generator.\n *\n * @category Common\n */\nexport function isAsyncGenerator(val) {\n  return isObject(val) && typeof Object(val)[Symbol.asyncIterator] === 'function' && typeof val.return === 'function' && typeof val.throw === 'function' && typeof val.next === 'function';\n}","/**\n *\n * parser\n *\n */\nimport { validateStreamEvent, parseStreamData } from './common.mjs';\nvar ControlChars = /*#__PURE__*/function (ControlChars) {\n  ControlChars[ControlChars[\"NewLine\"] = 10] = \"NewLine\";\n  ControlChars[ControlChars[\"CchunkiageReturn\"] = 13] = \"CchunkiageReturn\";\n  ControlChars[ControlChars[\"Space\"] = 32] = \"Space\";\n  ControlChars[ControlChars[\"Colon\"] = 58] = \"Colon\";\n  return ControlChars;\n}(ControlChars || {});\n/**\n * HTTP response chunk parser for graphql-sse's event stream messages.\n *\n * Reference: https://github.com/Azure/fetch-event-source/blob/main/src/parse.ts\n *\n * @private\n */\nexport function createParser() {\n  let buffer;\n  let position; // current read position\n  let fieldLength; // length of the `field` portion of the line\n  let discardTrailingNewline = false;\n  let message = {\n    event: '',\n    data: ''\n  };\n  let pending = [];\n  const decoder = new TextDecoder();\n  return function parse(chunk) {\n    if (buffer === undefined) {\n      buffer = chunk;\n      position = 0;\n      fieldLength = -1;\n    } else {\n      const concat = new Uint8Array(buffer.length + chunk.length);\n      concat.set(buffer);\n      concat.set(chunk, buffer.length);\n      buffer = concat;\n    }\n    const bufLength = buffer.length;\n    let lineStart = 0; // index where the current line starts\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === ControlChars.NewLine) {\n          lineStart = ++position; // skip to next char\n        }\n        discardTrailingNewline = false;\n      }\n      // look forward until the end of line\n      let lineEnd = -1; // index of the \\r or \\n char\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case ControlChars.Colon:\n            if (fieldLength === -1) {\n              // first colon in line\n              fieldLength = position - lineStart;\n            }\n            break;\n          // \\r case below should fallthrough to \\n:\n          case ControlChars.CchunkiageReturn:\n            discardTrailingNewline = true;\n          // eslint-disable-next-line no-fallthrough\n          case ControlChars.NewLine:\n            lineEnd = position;\n            break;\n        }\n      }\n      if (lineEnd === -1) {\n        // end of the buffer but the line hasn't ended\n        break;\n      } else if (lineStart === lineEnd) {\n        // empty line denotes end of incoming message\n        if (message.event || message.data) {\n          // NOT a server ping (\":\\n\\n\")\n          if (!message.event) throw new Error('Missing message event');\n          const event = validateStreamEvent(message.event);\n          const data = parseStreamData(event, message.data);\n          pending.push({\n            event,\n            data\n          });\n          message = {\n            event: '',\n            data: ''\n          };\n        }\n      } else if (fieldLength > 0) {\n        // end of line indicates message\n        const line = buffer.subarray(lineStart, lineEnd);\n        // exclude comments and lines with no values\n        // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n        // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n        const field = decoder.decode(line.subarray(0, fieldLength));\n        const valueOffset = fieldLength + (line[fieldLength + 1] === ControlChars.Space ? 2 : 1);\n        const value = decoder.decode(line.subarray(valueOffset));\n        switch (field) {\n          case 'event':\n            message.event = value;\n            break;\n          case 'data':\n            // append the new value if the message has data\n            message.data = message.data ? message.data + '\\n' + value : value;\n            break;\n        }\n      }\n      // next line\n      lineStart = position;\n      fieldLength = -1;\n    }\n    if (lineStart === bufLength) {\n      // finished reading\n      buffer = undefined;\n      const messages = [...pending];\n      pending = [];\n      return messages;\n    } else if (lineStart !== 0) {\n      // create a new view into buffer beginning at lineStart so we don't\n      // need to copy over the previous lines when we get the new chunk\n      buffer = buffer.subarray(lineStart);\n      position -= lineStart;\n    }\n  };\n}","/**\n *\n * client\n *\n */\nimport { createParser } from './parser.mjs';\nimport { isObject } from './utils.mjs';\nimport { TOKEN_HEADER_KEY } from './common.mjs';\n/** This file is the entry point for browsers, re-export common elements. */\nexport * from './common.mjs';\n/**\n * Creates a disposable GraphQL over SSE client to transmit\n * GraphQL operation results.\n *\n * If you have an HTTP/2 server, it is recommended to use the client\n * in \"distinct connections mode\" (`singleConnection = false`) which will\n * create a new SSE connection for each subscribe. This is the default.\n *\n * However, when dealing with HTTP/1 servers from a browser, consider using\n * the \"single connection mode\" (`singleConnection = true`) which will\n * use only one SSE connection.\n *\n * @category Client\n */\nexport function createClient(options) {\n  const {\n    singleConnection = false,\n    lazy = true,\n    lazyCloseTimeout = 0,\n    onNonLazyError = console.error,\n    /**\n     * Generates a v4 UUID to be used as the ID using `Math`\n     * as the random number generator. Supply your own generator\n     * in case you need more uniqueness.\n     *\n     * Reference: https://gist.github.com/jed/982883\n     */\n    generateID = function generateUUID() {\n      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n        const r = Math.random() * 16 | 0,\n          v = c == 'x' ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n      });\n    },\n    retryAttempts = 5,\n    retry = async function randomisedExponentialBackoff(retries) {\n      let retryDelay = 1000; // start with 1s delay\n      for (let i = 0; i < retries; i++) {\n        retryDelay *= 2;\n      }\n      await new Promise(resolve => setTimeout(resolve, retryDelay +\n      // add random timeout from 300ms to 3s\n      Math.floor(Math.random() * (3000 - 300) + 300)));\n    },\n    credentials = 'same-origin',\n    referrer,\n    referrerPolicy,\n    onMessage,\n    on: clientOn\n  } = options;\n  const fetchFn = options.fetchFn || fetch;\n  const AbortControllerImpl = options.abortControllerImpl || AbortController;\n  // we dont use yet another AbortController here because of\n  // node's max EventEmitters listeners being only 10\n  const client = (() => {\n    let disposed = false;\n    const listeners = [];\n    return {\n      get disposed() {\n        return disposed;\n      },\n      onDispose(cb) {\n        if (disposed) {\n          // empty the call stack and then call the cb\n          setTimeout(() => cb(), 0);\n          return () => {\n            // noop\n          };\n        }\n        listeners.push(cb);\n        return () => {\n          listeners.splice(listeners.indexOf(cb), 1);\n        };\n      },\n      dispose() {\n        if (disposed) return;\n        disposed = true;\n        // we copy the listeners so that onDispose unlistens dont \"pull the rug under our feet\"\n        for (const listener of [...listeners]) {\n          listener();\n        }\n      }\n    };\n  })();\n  let connCtrl,\n    conn,\n    locks = 0,\n    retryingErr = null,\n    retries = 0;\n  async function getOrConnect() {\n    try {\n      if (client.disposed) throw new Error('Client has been disposed');\n      return await (conn !== null && conn !== void 0 ? conn : conn = (async () => {\n        var _a, _b, _c;\n        if (retryingErr) {\n          await retry(retries);\n          // connection might've been aborted while waiting for retry\n          if (connCtrl.signal.aborted) throw new Error('Connection aborted by the client');\n          retries++;\n        }\n        (_a = clientOn === null || clientOn === void 0 ? void 0 : clientOn.connecting) === null || _a === void 0 ? void 0 : _a.call(clientOn, !!retryingErr);\n        // we must create a new controller here because lazy mode aborts currently active ones\n        connCtrl = new AbortControllerImpl();\n        const unlistenDispose = client.onDispose(() => connCtrl.abort());\n        connCtrl.signal.addEventListener('abort', () => {\n          unlistenDispose();\n          conn = undefined;\n        });\n        const url = typeof options.url === 'function' ? await options.url() : options.url;\n        if (connCtrl.signal.aborted) throw new Error('Connection aborted by the client');\n        const headers = typeof options.headers === 'function' ? await options.headers() : (_b = options.headers) !== null && _b !== void 0 ? _b : {};\n        if (connCtrl.signal.aborted) throw new Error('Connection aborted by the client');\n        let res;\n        try {\n          res = await fetchFn(url, {\n            signal: connCtrl.signal,\n            method: 'PUT',\n            credentials,\n            referrer,\n            referrerPolicy,\n            headers\n          });\n        } catch (err) {\n          throw new NetworkError(err);\n        }\n        if (res.status !== 201) throw new NetworkError(res);\n        const token = await res.text();\n        headers[TOKEN_HEADER_KEY] = token;\n        const connected = await connect({\n          signal: connCtrl.signal,\n          headers,\n          credentials,\n          referrer,\n          referrerPolicy,\n          url,\n          fetchFn,\n          onMessage: msg => {\n            var _a;\n            (_a = clientOn === null || clientOn === void 0 ? void 0 : clientOn.message) === null || _a === void 0 ? void 0 : _a.call(clientOn, msg);\n            onMessage === null || onMessage === void 0 ? void 0 : onMessage(msg); // @deprecated\n          }\n        });\n        (_c = clientOn === null || clientOn === void 0 ? void 0 : clientOn.connected) === null || _c === void 0 ? void 0 : _c.call(clientOn, !!retryingErr);\n        connected.waitForThrow().catch(() => conn = undefined);\n        return connected;\n      })());\n    } catch (err) {\n      // whatever problem happens during connect means the connection was not established\n      conn = undefined;\n      throw err;\n    }\n  }\n  // non-lazy mode always holds one lock to persist the connection\n  if (singleConnection && !lazy) {\n    (async () => {\n      locks++;\n      for (;;) {\n        try {\n          const {\n            waitForThrow\n          } = await getOrConnect();\n          await waitForThrow();\n        } catch (err) {\n          if (client.disposed) return;\n          // all non-network errors are worth reporting immediately\n          if (!(err instanceof NetworkError)) return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(err);\n          // was a network error, get rid of the current connection to ensure retries\n          conn = undefined;\n          // retries are not allowed or we tried to many times, report error\n          if (!retryAttempts || retries >= retryAttempts) return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(err);\n          // try again\n          retryingErr = err;\n        }\n      }\n    })();\n  }\n  function subscribe(request, sink, on) {\n    if (!singleConnection) {\n      // distinct connections mode\n      const control = new AbortControllerImpl();\n      const unlisten = client.onDispose(() => {\n        unlisten();\n        control.abort();\n      });\n      (async () => {\n        var _a, _b, _c, _d, _e;\n        let retryingErr = null,\n          retries = 0;\n        for (;;) {\n          try {\n            if (retryingErr) {\n              await retry(retries);\n              // connection might've been aborted while waiting for retry\n              if (control.signal.aborted) throw new Error('Connection aborted by the client');\n              retries++;\n            }\n            (_a = clientOn === null || clientOn === void 0 ? void 0 : clientOn.connecting) === null || _a === void 0 ? void 0 : _a.call(clientOn, !!retryingErr);\n            (_b = on === null || on === void 0 ? void 0 : on.connecting) === null || _b === void 0 ? void 0 : _b.call(on, !!retryingErr);\n            const url = typeof options.url === 'function' ? await options.url() : options.url;\n            if (control.signal.aborted) throw new Error('Connection aborted by the client');\n            const headers = typeof options.headers === 'function' ? await options.headers() : (_c = options.headers) !== null && _c !== void 0 ? _c : {};\n            if (control.signal.aborted) throw new Error('Connection aborted by the client');\n            const {\n              getResults\n            } = await connect({\n              signal: control.signal,\n              headers: {\n                ...headers,\n                'content-type': 'application/json; charset=utf-8'\n              },\n              credentials,\n              referrer,\n              referrerPolicy,\n              url,\n              body: JSON.stringify(request),\n              fetchFn,\n              onMessage: msg => {\n                var _a, _b;\n                (_a = clientOn === null || clientOn === void 0 ? void 0 : clientOn.message) === null || _a === void 0 ? void 0 : _a.call(clientOn, msg);\n                (_b = on === null || on === void 0 ? void 0 : on.message) === null || _b === void 0 ? void 0 : _b.call(on, msg);\n                onMessage === null || onMessage === void 0 ? void 0 : onMessage(msg); // @deprecated\n              }\n            });\n            (_d = clientOn === null || clientOn === void 0 ? void 0 : clientOn.connected) === null || _d === void 0 ? void 0 : _d.call(clientOn, !!retryingErr);\n            (_e = on === null || on === void 0 ? void 0 : on.connected) === null || _e === void 0 ? void 0 : _e.call(on, !!retryingErr);\n            for await (const result of getResults()) {\n              // only after receiving results are future connects not considered retries.\n              // this is because a client might successfully connect, but the server\n              // ends up terminating the connection afterwards before streaming anything.\n              // of course, if the client completes the subscription, this loop will\n              // break and therefore stop the stream (it wont reconnect)\n              retryingErr = null;\n              retries = 0;\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              sink.next(result);\n            }\n            return control.abort();\n          } catch (err) {\n            if (control.signal.aborted) return;\n            // all non-network errors are worth reporting immediately\n            if (!(err instanceof NetworkError)) throw err;\n            // retries are not allowed or we tried to many times, report error\n            if (!retryAttempts || retries >= retryAttempts) throw err;\n            // try again\n            retryingErr = err;\n          }\n        }\n      })().then(() => sink.complete()).catch(err => sink.error(err));\n      return () => control.abort();\n    }\n    // single connection mode\n    locks++;\n    const control = new AbortControllerImpl();\n    const unlisten = client.onDispose(() => {\n      unlisten();\n      control.abort();\n    });\n    (async () => {\n      const operationId = generateID();\n      request = {\n        ...request,\n        extensions: {\n          ...request.extensions,\n          operationId\n        }\n      };\n      let complete = null;\n      for (;;) {\n        complete = null;\n        try {\n          const {\n            url,\n            headers,\n            getResults\n          } = await getOrConnect();\n          let res;\n          try {\n            res = await fetchFn(url, {\n              signal: control.signal,\n              method: 'POST',\n              credentials,\n              referrer,\n              referrerPolicy,\n              headers: {\n                ...headers,\n                'content-type': 'application/json; charset=utf-8'\n              },\n              body: JSON.stringify(request)\n            });\n          } catch (err) {\n            throw new NetworkError(err);\n          }\n          if (res.status !== 202) throw new NetworkError(res);\n          complete = async () => {\n            let res;\n            try {\n              const control = new AbortControllerImpl();\n              const unlisten = client.onDispose(() => {\n                unlisten();\n                control.abort();\n              });\n              res = await fetchFn(url + '?operationId=' + operationId, {\n                signal: control.signal,\n                method: 'DELETE',\n                credentials,\n                referrer,\n                referrerPolicy,\n                headers\n              });\n            } catch (err) {\n              throw new NetworkError(err);\n            }\n            if (res.status !== 200) throw new NetworkError(res);\n          };\n          for await (const result of getResults({\n            signal: control.signal,\n            operationId\n          })) {\n            // only after receiving results are future connects not considered retries.\n            // this is because a client might successfully connect, but the server\n            // ends up terminating the connection afterwards before streaming anything.\n            // of course, if the client completes the subscription, this loop will\n            // break and therefore stop the stream (it wont reconnect)\n            retryingErr = null;\n            retries = 0;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            sink.next(result);\n          }\n          complete = null; // completed by the server\n          return control.abort();\n        } catch (err) {\n          if (control.signal.aborted) return await (complete === null || complete === void 0 ? void 0 : complete());\n          // all non-network errors are worth reporting immediately\n          if (!(err instanceof NetworkError)) {\n            control.abort(); // TODO: tests for making sure the control's aborted\n            throw err;\n          }\n          // was a network error, get rid of the current connection to ensure retries\n          // but only if the client is running in lazy mode (otherwise the non-lazy lock will get rid of the connection)\n          if (lazy) {\n            conn = undefined;\n          }\n          // retries are not allowed or we tried to many times, report error\n          if (!retryAttempts || retries >= retryAttempts) {\n            control.abort(); // TODO: tests for making sure the control's aborted\n            throw err;\n          }\n          // try again\n          retryingErr = err;\n        } finally {\n          // release lock if subscription is aborted\n          if (control.signal.aborted && --locks === 0) {\n            if (isFinite(lazyCloseTimeout) && lazyCloseTimeout > 0) {\n              // allow for the specified calmdown time and then close the\n              // connection, only if no lock got created in the meantime and\n              // if the connection is still open\n              setTimeout(() => {\n                if (!locks) connCtrl.abort();\n              }, lazyCloseTimeout);\n            } else {\n              // otherwise close immediately\n              connCtrl.abort();\n            }\n          }\n        }\n      }\n    })().then(() => sink.complete()).catch(err => sink.error(err));\n    return () => control.abort();\n  }\n  return {\n    subscribe,\n    iterate(request, on) {\n      const pending = [];\n      const deferred = {\n        done: false,\n        error: null,\n        resolve: () => {\n          // noop\n        }\n      };\n      const dispose = subscribe(request, {\n        next(val) {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          pending.push(val);\n          deferred.resolve();\n        },\n        error(err) {\n          deferred.done = true;\n          deferred.error = err;\n          deferred.resolve();\n        },\n        complete() {\n          deferred.done = true;\n          deferred.resolve();\n        }\n      }, on);\n      const iterator = async function* iterator() {\n        for (;;) {\n          if (!pending.length) {\n            // only wait if there are no pending messages available\n            await new Promise(resolve => deferred.resolve = resolve);\n          }\n          // first flush\n          while (pending.length) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            yield pending.shift();\n          }\n          // then error\n          if (deferred.error) {\n            throw deferred.error;\n          }\n          // or complete\n          if (deferred.done) {\n            return;\n          }\n        }\n      }();\n      iterator.throw = async err => {\n        if (!deferred.done) {\n          deferred.done = true;\n          deferred.error = err;\n          deferred.resolve();\n        }\n        return {\n          done: true,\n          value: undefined\n        };\n      };\n      iterator.return = async () => {\n        dispose();\n        return {\n          done: true,\n          value: undefined\n        };\n      };\n      return iterator;\n    },\n    dispose() {\n      client.dispose();\n    }\n  };\n}\n/**\n * A network error caused by the client or an unexpected response from the server.\n *\n * Network errors are considered retryable, all others error types will be reported\n * immediately.\n *\n * To avoid bundling DOM typings (because the client can run in Node env too),\n * you should supply the `Response` generic depending on your Fetch implementation.\n *\n * @category Client\n */\nexport class NetworkError extends Error {\n  constructor(msgOrErrOrResponse) {\n    let message, response;\n    if (isResponseLike(msgOrErrOrResponse)) {\n      response = msgOrErrOrResponse;\n      message = 'Server responded with ' + msgOrErrOrResponse.status + ': ' + msgOrErrOrResponse.statusText;\n    } else if (msgOrErrOrResponse instanceof Error) message = msgOrErrOrResponse.message;else message = String(msgOrErrOrResponse);\n    super(message);\n    this.name = this.constructor.name;\n    this.response = response;\n  }\n}\nfunction isResponseLike(val) {\n  return isObject(val) && typeof val['ok'] === 'boolean' && typeof val['status'] === 'number' && typeof val['statusText'] === 'string';\n}\nasync function connect(options) {\n  const {\n    signal,\n    url,\n    credentials,\n    headers,\n    body,\n    referrer,\n    referrerPolicy,\n    fetchFn,\n    onMessage\n  } = options;\n  const waiting = {};\n  const queue = {};\n  let res;\n  try {\n    res = await fetchFn(url, {\n      signal,\n      method: body ? 'POST' : 'GET',\n      credentials,\n      referrer,\n      referrerPolicy,\n      headers: {\n        ...headers,\n        accept: 'text/event-stream'\n      },\n      body\n    });\n  } catch (err) {\n    throw new NetworkError(err);\n  }\n  if (!res.ok) throw new NetworkError(res);\n  if (!res.body) throw new Error('Missing response body');\n  let error = null;\n  let waitingForThrow;\n  (async () => {\n    var _a;\n    try {\n      const parse = createParser();\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      for await (const chunk of toAsyncIterator(res.body)) {\n        if (typeof chunk === 'string') throw error = new Error(`Unexpected string chunk \"${chunk}\"`); // set error as fatal indicator\n        // read chunk and if messages are ready, yield them\n        let msgs;\n        try {\n          msgs = parse(chunk);\n        } catch (err) {\n          throw error = err; // set error as fatal indicator\n        }\n        if (!msgs) continue;\n        for (const msg of msgs) {\n          try {\n            onMessage === null || onMessage === void 0 ? void 0 : onMessage(msg);\n          } catch (err) {\n            throw error = err; // set error as fatal indicator\n          }\n          const operationId = msg.data && 'id' in msg.data ? msg.data.id // StreamDataForID\n          : ''; // StreamData\n          if (!(operationId in queue)) queue[operationId] = [];\n          switch (msg.event) {\n            case 'next':\n              if (operationId) queue[operationId].push(msg.data.payload);else queue[operationId].push(msg.data);\n              break;\n            case 'complete':\n              queue[operationId].push('complete');\n              break;\n            default:\n              throw error = new Error(`Unexpected message event \"${msg.event}\"`);\n            // set error as fatal indicator\n          }\n          (_a = waiting[operationId]) === null || _a === void 0 ? void 0 : _a.proceed();\n        }\n      }\n      // some browsers (like Safari) closes the connection without errors even on abrupt server shutdowns,\n      // we therefore make sure that no stream is active and waiting for results (not completed)\n      if (Object.keys(waiting).length) {\n        throw new Error('Connection closed while having active streams');\n      }\n    } catch (err) {\n      if (!error && Object.keys(waiting).length) {\n        // we assume the error is most likely a NetworkError because there are listeners waiting for events.\n        // additionally, the `error` is another indicator because we set it early if the error is considered fatal\n        error = new NetworkError(err);\n      } else {\n        error = err;\n      }\n      waitingForThrow === null || waitingForThrow === void 0 ? void 0 : waitingForThrow(error);\n    } finally {\n      Object.values(waiting).forEach(({\n        proceed\n      }) => proceed());\n    }\n  })();\n  return {\n    url,\n    headers,\n    waitForThrow: () => new Promise((_, reject) => {\n      if (error) return reject(error);\n      waitingForThrow = reject;\n    }),\n    async *getResults(options) {\n      var _a;\n      const {\n        signal,\n        operationId = ''\n      } = options !== null && options !== void 0 ? options : {};\n      // operationId === '' ? StreamData : StreamDataForID\n      try {\n        for (;;) {\n          while ((_a = queue[operationId]) === null || _a === void 0 ? void 0 : _a.length) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const result = queue[operationId].shift();\n            if (result === 'complete') return;\n            yield result;\n          }\n          if (error) throw error;\n          if (signal === null || signal === void 0 ? void 0 : signal.aborted) throw new Error('Getting results aborted by the client');\n          await new Promise(resolve => {\n            const proceed = () => {\n              signal === null || signal === void 0 ? void 0 : signal.removeEventListener('abort', proceed);\n              delete waiting[operationId];\n              resolve();\n            };\n            signal === null || signal === void 0 ? void 0 : signal.addEventListener('abort', proceed);\n            waiting[operationId] = {\n              proceed\n            };\n          });\n        }\n      } finally {\n        delete queue[operationId];\n      }\n    }\n  };\n}\n/** Isomorphic ReadableStream to AsyncIterator converter. */\nfunction toAsyncIterator(val) {\n  // node stream is already async iterable\n  if (typeof Object(val)[Symbol.asyncIterator] === 'function') {\n    val = val;\n    return val[Symbol.asyncIterator]();\n  }\n  // convert web stream to async iterable\n  return async function* () {\n    const reader = val.getReader();\n    let result;\n    do {\n      result = await reader.read();\n      if (result.value !== undefined) yield result.value;\n    } while (!result.done);\n  }();\n}","import { Observable } from 'rxjs';\nimport {\n  GraphQLRequestHandler,\n  GraphQLRequestOptions,\n  GraphQLResponseData,\n} from '../types';\nimport { Client, createClient } from 'graphql-sse';\nimport { simpleResponseObserver } from '../utils';\n\nexport class SSERequestHandler implements GraphQLRequestHandler {\n  client?: Client;\n  cleanup?: () => void;\n\n  handle(request: GraphQLRequestOptions): Observable<GraphQLResponseData> {\n    return new Observable((subscriber) => {\n      this.client = createClient({\n        url: request.url,\n        credentials: request.withCredentials ? 'include' : 'same-origin',\n        headers: request.headers?.reduce(\n          (acc, { key, value }) => {\n            acc[key] = value;\n            return acc;\n          },\n          {} as Record<string, string>\n        ),\n      });\n\n      if (!this.client) {\n        throw new Error('Could not create SSE client!');\n      }\n      const requestStartTimestamp = Date.now();\n      this.cleanup = this.client.subscribe(\n        {\n          query: request.query,\n          variables: request.variables,\n          operationName: request.selectedOperation ?? undefined,\n          extensions: request.extensions,\n        },\n        simpleResponseObserver(subscriber, request.url, requestStartTimestamp)\n      );\n\n      return () => {\n        this.destroy();\n      };\n    });\n  }\n\n\n  async destroy() {\n    try {\n      this.cleanup?.();\n      this.cleanup = undefined;\n      await this.client?.dispose();\n      this.client = undefined;\n    } catch (err) {\n      console.error(err);\n    }\n  }\n}\n"],"names":["isObject","val","TOKEN_HEADER_KEY","validateStreamEvent","parseStreamData","data","ControlChars","createParser","buffer","position","fieldLength","discardTrailingNewline","message","pending","decoder","chunk","concat","bufLength","lineStart","lineEnd","event","validateStreamEvent","data","parseStreamData","line","field","valueOffset","value","messages","createClient","options","singleConnection","lazy","lazyCloseTimeout","onNonLazyError","generateID","c","r","retryAttempts","retry","retries","__async","retryDelay","i","resolve","credentials","referrer","referrerPolicy","onMessage","clientOn","fetchFn","AbortControllerImpl","client","disposed","listeners","cb","listener","connCtrl","conn","locks","retryingErr","getOrConnect","_a","_b","_c","unlistenDispose","url","headers","res","err","NetworkError","token","TOKEN_HEADER_KEY","connected","connect","msg","waitForThrow","subscribe","request","sink","on","control","unlisten","_d","_e","getResults","__spreadProps","__spreadValues","iter","__forAwait","more","temp","error","result","operationId","complete","pending","deferred","dispose","val","iterator","__asyncGenerator","__await","msgOrErrOrResponse","message","response","isResponseLike","isObject","signal","body","waiting","queue","waitingForThrow","parse","createParser","toAsyncIterator","chunk","msgs","proceed","_","reject","reader","SSERequestHandler","handle","request","Observable","subscriber","client","createClient","url","credentials","withCredentials","headers","reduce","acc","key","value","Error","requestStartTimestamp","Date","now","cleanup","subscribe","query","variables","operationName","selectedOperation","undefined","extensions","simpleResponseObserver","destroy","__async","dispose","err","console","error"],"mappings":"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","debug_id":"95fbb782-2f46-549c-b8b9-ac1094956085"}