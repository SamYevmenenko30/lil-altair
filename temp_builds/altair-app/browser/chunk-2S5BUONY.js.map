{"version":3,"sources":["../../node_modules/.pnpm/graphql-ws@5.8.2_graphql@15.5.1/node_modules/graphql-ws/lib/utils.mjs","../../node_modules/.pnpm/graphql-ws@5.8.2_graphql@15.5.1/node_modules/graphql-ws/lib/common.mjs","../../node_modules/.pnpm/graphql-ws@5.8.2_graphql@15.5.1/node_modules/graphql-ws/lib/client.mjs","../altair-core/src/request/handlers/graphql-ws.ts"],"sourcesContent":["// Extremely small optimisation, reduces runtime prototype traversal\nconst baseHasOwnProperty = Object.prototype.hasOwnProperty;\n/** @private */\nexport function isObject(val) {\n  return typeof val === 'object' && val !== null;\n}\n/** @private */\nexport function isAsyncIterable(val) {\n  return typeof Object(val)[Symbol.asyncIterator] === 'function';\n}\n/** @private */\nexport function isAsyncGenerator(val) {\n  return isObject(val) && typeof Object(val)[Symbol.asyncIterator] === 'function' && typeof val.return === 'function'\n  // for lazy ones, we only need the return anyway\n  // typeof val.throw === 'function' &&\n  // typeof val.next === 'function'\n  ;\n}\n/** @private */\nexport function areGraphQLErrors(obj) {\n  return Array.isArray(obj) &&\n  // must be at least one error\n  obj.length > 0 &&\n  // error has at least a message\n  obj.every(ob => 'message' in ob);\n}\n/** @private */\nexport function hasOwnProperty(obj, prop) {\n  return baseHasOwnProperty.call(obj, prop);\n}\n/** @private */\nexport function hasOwnObjectProperty(obj, prop) {\n  return baseHasOwnProperty.call(obj, prop) && isObject(obj[prop]);\n}\n/** @private */\nexport function hasOwnArrayProperty(obj, prop) {\n  return baseHasOwnProperty.call(obj, prop) && Array.isArray(obj[prop]);\n}\n/** @private */\nexport function hasOwnStringProperty(obj, prop) {\n  return baseHasOwnProperty.call(obj, prop) && typeof obj[prop] === 'string';\n}\n/**\n * Limits the WebSocket close event reason to not exceed a length of one frame.\n * Reference: https://datatracker.ietf.org/doc/html/rfc6455#section-5.2.\n *\n * @private\n */\nexport function limitCloseReason(reason, whenTooLong) {\n  return reason.length < 124 ? reason : whenTooLong;\n}","/**\n *\n * common\n *\n */\nimport { isObject, areGraphQLErrors, hasOwnProperty, hasOwnObjectProperty, hasOwnStringProperty } from './utils.mjs';\n/**\n * The WebSocket sub-protocol used for the [GraphQL over WebSocket Protocol](/PROTOCOL.md).\n *\n * @category Common\n */\nexport const GRAPHQL_TRANSPORT_WS_PROTOCOL = 'graphql-transport-ws';\n/**\n * The deprecated subprotocol used by [subscriptions-transport-ws](https://github.com/apollographql/subscriptions-transport-ws).\n *\n * @private\n */\nexport const DEPRECATED_GRAPHQL_WS_PROTOCOL = 'graphql-ws';\n/**\n * `graphql-ws` expected and standard close codes of the [GraphQL over WebSocket Protocol](/PROTOCOL.md).\n *\n * @category Common\n */\nexport var CloseCode = /*#__PURE__*/function (CloseCode) {\n  CloseCode[CloseCode[\"InternalServerError\"] = 4500] = \"InternalServerError\";\n  CloseCode[CloseCode[\"InternalClientError\"] = 4005] = \"InternalClientError\";\n  CloseCode[CloseCode[\"BadRequest\"] = 4400] = \"BadRequest\";\n  CloseCode[CloseCode[\"BadResponse\"] = 4004] = \"BadResponse\";\n  /** Tried subscribing before connect ack */\n  CloseCode[CloseCode[\"Unauthorized\"] = 4401] = \"Unauthorized\";\n  CloseCode[CloseCode[\"Forbidden\"] = 4403] = \"Forbidden\";\n  CloseCode[CloseCode[\"SubprotocolNotAcceptable\"] = 4406] = \"SubprotocolNotAcceptable\";\n  CloseCode[CloseCode[\"ConnectionInitialisationTimeout\"] = 4408] = \"ConnectionInitialisationTimeout\";\n  CloseCode[CloseCode[\"ConnectionAcknowledgementTimeout\"] = 4504] = \"ConnectionAcknowledgementTimeout\";\n  /** Subscriber distinction is very important */\n  CloseCode[CloseCode[\"SubscriberAlreadyExists\"] = 4409] = \"SubscriberAlreadyExists\";\n  CloseCode[CloseCode[\"TooManyInitialisationRequests\"] = 4429] = \"TooManyInitialisationRequests\";\n  return CloseCode;\n}(CloseCode || {});\n/**\n * Types of messages allowed to be sent by the client/server over the WS protocol.\n *\n * @category Common\n */\nexport var MessageType = /*#__PURE__*/function (MessageType) {\n  MessageType[\"ConnectionInit\"] = \"connection_init\";\n  MessageType[\"ConnectionAck\"] = \"connection_ack\";\n  MessageType[\"Ping\"] = \"ping\";\n  MessageType[\"Pong\"] = \"pong\";\n  MessageType[\"Subscribe\"] = \"subscribe\";\n  MessageType[\"Next\"] = \"next\";\n  MessageType[\"Error\"] = \"error\";\n  MessageType[\"Complete\"] = \"complete\";\n  return MessageType;\n}(MessageType || {});\n/**\n * Checks if the provided value is a message.\n *\n * @category Common\n */\nexport function isMessage(val) {\n  if (isObject(val)) {\n    // all messages must have the `type` prop\n    if (!hasOwnStringProperty(val, 'type')) {\n      return false;\n    }\n    // validate other properties depending on the `type`\n    switch (val.type) {\n      case MessageType.ConnectionInit:\n        // the connection init message can have optional payload object\n        return !hasOwnProperty(val, 'payload') || val.payload === undefined || isObject(val.payload);\n      case MessageType.ConnectionAck:\n      case MessageType.Ping:\n      case MessageType.Pong:\n        // the connection ack, ping and pong messages can have optional payload object too\n        return !hasOwnProperty(val, 'payload') || val.payload === undefined || isObject(val.payload);\n      case MessageType.Subscribe:\n        return hasOwnStringProperty(val, 'id') && hasOwnObjectProperty(val, 'payload') && (!hasOwnProperty(val.payload, 'operationName') || val.payload.operationName === undefined || val.payload.operationName === null || typeof val.payload.operationName === 'string') && hasOwnStringProperty(val.payload, 'query') && (!hasOwnProperty(val.payload, 'variables') || val.payload.variables === undefined || val.payload.variables === null || hasOwnObjectProperty(val.payload, 'variables')) && (!hasOwnProperty(val.payload, 'extensions') || val.payload.extensions === undefined || val.payload.extensions === null || hasOwnObjectProperty(val.payload, 'extensions'));\n      case MessageType.Next:\n        return hasOwnStringProperty(val, 'id') && hasOwnObjectProperty(val, 'payload');\n      case MessageType.Error:\n        return hasOwnStringProperty(val, 'id') && areGraphQLErrors(val.payload);\n      case MessageType.Complete:\n        return hasOwnStringProperty(val, 'id');\n      default:\n        return false;\n    }\n  }\n  return false;\n}\n/**\n * Parses the raw websocket message data to a valid message.\n *\n * @category Common\n */\nexport function parseMessage(data, reviver) {\n  if (isMessage(data)) {\n    return data;\n  }\n  if (typeof data !== 'string') {\n    throw new Error('Message not parsable');\n  }\n  const message = JSON.parse(data, reviver);\n  if (!isMessage(message)) {\n    throw new Error('Invalid message');\n  }\n  return message;\n}\n/**\n * Stringifies a valid message ready to be sent through the socket.\n *\n * @category Common\n */\nexport function stringifyMessage(msg, replacer) {\n  if (!isMessage(msg)) {\n    throw new Error('Cannot stringify invalid message');\n  }\n  return JSON.stringify(msg, replacer);\n}","/**\n *\n * client\n *\n */\nimport { GRAPHQL_TRANSPORT_WS_PROTOCOL, CloseCode, MessageType, parseMessage, stringifyMessage } from './common.mjs';\nimport { isObject, limitCloseReason } from './utils.mjs';\n/** This file is the entry point for browsers, re-export common elements. */\nexport * from './common.mjs';\n/**\n * Creates a disposable GraphQL over WebSocket client.\n *\n * @category Client\n */\nexport function createClient(options) {\n  const {\n    url,\n    connectionParams,\n    lazy = true,\n    onNonLazyError = console.error,\n    lazyCloseTimeout = 0,\n    keepAlive = 0,\n    disablePong,\n    connectionAckWaitTimeout = 0,\n    retryAttempts = 5,\n    retryWait = async function randomisedExponentialBackoff(retries) {\n      let retryDelay = 1000; // start with 1s delay\n      for (let i = 0; i < retries; i++) {\n        retryDelay *= 2;\n      }\n      await new Promise(resolve => setTimeout(resolve, retryDelay +\n      // add random timeout from 300ms to 3s\n      Math.floor(Math.random() * (3000 - 300) + 300)));\n    },\n    shouldRetry = isLikeCloseEvent,\n    isFatalConnectionProblem,\n    on,\n    webSocketImpl,\n    /**\n     * Generates a v4 UUID to be used as the ID using `Math`\n     * as the random number generator. Supply your own generator\n     * in case you need more uniqueness.\n     *\n     * Reference: https://gist.github.com/jed/982883\n     */\n    generateID = function generateUUID() {\n      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n        const r = Math.random() * 16 | 0,\n          v = c == 'x' ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n      });\n    },\n    jsonMessageReplacer: replacer,\n    jsonMessageReviver: reviver\n  } = options;\n  let ws;\n  if (webSocketImpl) {\n    if (!isWebSocket(webSocketImpl)) {\n      throw new Error('Invalid WebSocket implementation provided');\n    }\n    ws = webSocketImpl;\n  } else if (typeof WebSocket !== 'undefined') {\n    ws = WebSocket;\n  } else if (typeof global !== 'undefined') {\n    ws = global.WebSocket ||\n    // @ts-expect-error: Support more browsers\n    global.MozWebSocket;\n  } else if (typeof window !== 'undefined') {\n    ws = window.WebSocket ||\n    // @ts-expect-error: Support more browsers\n    window.MozWebSocket;\n  }\n  if (!ws) throw new Error(\"WebSocket implementation missing; on Node you can `import WebSocket from 'ws';` and pass `webSocketImpl: WebSocket` to `createClient`\");\n  const WebSocketImpl = ws;\n  // websocket status emitter, subscriptions are handled differently\n  const emitter = (() => {\n    const message = (() => {\n      const listeners = {};\n      return {\n        on(id, listener) {\n          listeners[id] = listener;\n          return () => {\n            delete listeners[id];\n          };\n        },\n        emit(message) {\n          var _a;\n          if ('id' in message) (_a = listeners[message.id]) === null || _a === void 0 ? void 0 : _a.call(listeners, message);\n        }\n      };\n    })();\n    const listeners = {\n      connecting: (on === null || on === void 0 ? void 0 : on.connecting) ? [on.connecting] : [],\n      opened: (on === null || on === void 0 ? void 0 : on.opened) ? [on.opened] : [],\n      connected: (on === null || on === void 0 ? void 0 : on.connected) ? [on.connected] : [],\n      ping: (on === null || on === void 0 ? void 0 : on.ping) ? [on.ping] : [],\n      pong: (on === null || on === void 0 ? void 0 : on.pong) ? [on.pong] : [],\n      message: (on === null || on === void 0 ? void 0 : on.message) ? [message.emit, on.message] : [message.emit],\n      closed: (on === null || on === void 0 ? void 0 : on.closed) ? [on.closed] : [],\n      error: (on === null || on === void 0 ? void 0 : on.error) ? [on.error] : []\n    };\n    return {\n      onMessage: message.on,\n      on(event, listener) {\n        const l = listeners[event];\n        l.push(listener);\n        return () => {\n          l.splice(l.indexOf(listener), 1);\n        };\n      },\n      emit(event, ...args) {\n        // we copy the listeners so that unlistens dont \"pull the rug under our feet\"\n        for (const listener of [...listeners[event]]) {\n          // @ts-expect-error: The args should fit\n          listener(...args);\n        }\n      }\n    };\n  })();\n  // invokes the callback either when an error or closed event is emitted,\n  // first one that gets called prevails, other emissions are ignored\n  function errorOrClosed(cb) {\n    const listening = [\n    // errors are fatal and more critical than close events, throw them first\n    emitter.on('error', err => {\n      listening.forEach(unlisten => unlisten());\n      cb(err);\n    }),\n    // closes can be graceful and not fatal, throw them second (if error didnt throw)\n    emitter.on('closed', event => {\n      listening.forEach(unlisten => unlisten());\n      cb(event);\n    })];\n  }\n  let connecting,\n    locks = 0,\n    retrying = false,\n    retries = 0,\n    disposed = false;\n  async function connect() {\n    const [socket, throwOnClose] = await (connecting !== null && connecting !== void 0 ? connecting : connecting = new Promise((connected, denied) => (async () => {\n      if (retrying) {\n        await retryWait(retries);\n        // subscriptions might complete while waiting for retry\n        if (!locks) {\n          connecting = undefined;\n          return denied({\n            code: 1000,\n            reason: 'All Subscriptions Gone'\n          });\n        }\n        retries++;\n      }\n      emitter.emit('connecting');\n      const socket = new WebSocketImpl(typeof url === 'function' ? await url() : url, GRAPHQL_TRANSPORT_WS_PROTOCOL);\n      let connectionAckTimeout, queuedPing;\n      function enqueuePing() {\n        if (isFinite(keepAlive) && keepAlive > 0) {\n          clearTimeout(queuedPing); // in case where a pong was received before a ping (this is valid behaviour)\n          queuedPing = setTimeout(() => {\n            if (socket.readyState === WebSocketImpl.OPEN) {\n              socket.send(stringifyMessage({\n                type: MessageType.Ping\n              }));\n              emitter.emit('ping', false, undefined);\n            }\n          }, keepAlive);\n        }\n      }\n      errorOrClosed(errOrEvent => {\n        connecting = undefined;\n        clearTimeout(connectionAckTimeout);\n        clearTimeout(queuedPing);\n        denied(errOrEvent);\n        if (isLikeCloseEvent(errOrEvent) && errOrEvent.code === 4499) {\n          socket.close(4499, 'Terminated'); // close event is artificial and emitted manually, see `Client.terminate()` below\n          socket.onerror = null;\n          socket.onclose = null;\n        }\n      });\n      socket.onerror = err => emitter.emit('error', err);\n      socket.onclose = event => emitter.emit('closed', event);\n      socket.onopen = async () => {\n        try {\n          emitter.emit('opened', socket);\n          const payload = typeof connectionParams === 'function' ? await connectionParams() : connectionParams;\n          // connectionParams might take too long causing the server to kick off the client\n          // the necessary error/close event is already reported - simply stop execution\n          if (socket.readyState !== WebSocketImpl.OPEN) return;\n          socket.send(stringifyMessage(payload ? {\n            type: MessageType.ConnectionInit,\n            payload\n          } : {\n            type: MessageType.ConnectionInit\n            // payload is completely absent if not provided\n          }, replacer));\n          if (isFinite(connectionAckWaitTimeout) && connectionAckWaitTimeout > 0) {\n            connectionAckTimeout = setTimeout(() => {\n              socket.close(CloseCode.ConnectionAcknowledgementTimeout, 'Connection acknowledgement timeout');\n            }, connectionAckWaitTimeout);\n          }\n          enqueuePing(); // enqueue ping (noop if disabled)\n        } catch (err) {\n          emitter.emit('error', err);\n          socket.close(CloseCode.InternalClientError, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, 'Internal client error'));\n        }\n      };\n      let acknowledged = false;\n      socket.onmessage = ({\n        data\n      }) => {\n        try {\n          const message = parseMessage(data, reviver);\n          emitter.emit('message', message);\n          if (message.type === 'ping' || message.type === 'pong') {\n            emitter.emit(message.type, true, message.payload); // received\n            if (message.type === 'pong') {\n              enqueuePing(); // enqueue next ping (noop if disabled)\n            } else if (!disablePong) {\n              // respond with pong on ping\n              socket.send(stringifyMessage(message.payload ? {\n                type: MessageType.Pong,\n                payload: message.payload\n              } : {\n                type: MessageType.Pong\n                // payload is completely absent if not provided\n              }));\n              emitter.emit('pong', false, message.payload);\n            }\n            return; // ping and pongs can be received whenever\n          }\n          if (acknowledged) return; // already connected and acknowledged\n          if (message.type !== MessageType.ConnectionAck) throw new Error(`First message cannot be of type ${message.type}`);\n          clearTimeout(connectionAckTimeout);\n          acknowledged = true;\n          emitter.emit('connected', socket, message.payload); // connected = socket opened + acknowledged\n          retrying = false; // future lazy connects are not retries\n          retries = 0; // reset the retries on connect\n          connected([socket, new Promise((_, reject) => errorOrClosed(reject))]);\n        } catch (err) {\n          socket.onmessage = null; // stop reading messages as soon as reading breaks once\n          emitter.emit('error', err);\n          socket.close(CloseCode.BadResponse, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, 'Bad response'));\n        }\n      };\n    })()));\n    // if the provided socket is in a closing state, wait for the throw on close\n    if (socket.readyState === WebSocketImpl.CLOSING) await throwOnClose;\n    let release = () => {\n      // releases this connection\n    };\n    const released = new Promise(resolve => release = resolve);\n    return [socket, release, Promise.race([\n    // wait for\n    released.then(() => {\n      if (!locks) {\n        // and if no more locks are present, complete the connection\n        const complete = () => socket.close(1000, 'Normal Closure');\n        if (isFinite(lazyCloseTimeout) && lazyCloseTimeout > 0) {\n          // if the keepalive is set, allow for the specified calmdown time and\n          // then complete. but only if no lock got created in the meantime and\n          // if the socket is still open\n          setTimeout(() => {\n            if (!locks && socket.readyState === WebSocketImpl.OPEN) complete();\n          }, lazyCloseTimeout);\n        } else {\n          // otherwise complete immediately\n          complete();\n        }\n      }\n    }),\n    // or\n    throwOnClose])];\n  }\n  /**\n   * Checks the `connect` problem and evaluates if the client should retry.\n   */\n  function shouldRetryConnectOrThrow(errOrCloseEvent) {\n    // some close codes are worth reporting immediately\n    if (isLikeCloseEvent(errOrCloseEvent) && (isFatalInternalCloseCode(errOrCloseEvent.code) || [CloseCode.InternalServerError, CloseCode.InternalClientError, CloseCode.BadRequest, CloseCode.BadResponse, CloseCode.Unauthorized,\n    // CloseCode.Forbidden, might grant access out after retry\n    CloseCode.SubprotocolNotAcceptable,\n    // CloseCode.ConnectionInitialisationTimeout, might not time out after retry\n    // CloseCode.ConnectionAcknowledgementTimeout, might not time out after retry\n    CloseCode.SubscriberAlreadyExists, CloseCode.TooManyInitialisationRequests\n    // 4499, // Terminated, probably because the socket froze, we want to retry\n    ].includes(errOrCloseEvent.code))) throw errOrCloseEvent;\n    // client was disposed, no retries should proceed regardless\n    if (disposed) return false;\n    // normal closure (possibly all subscriptions have completed)\n    // if no locks were acquired in the meantime, shouldnt try again\n    if (isLikeCloseEvent(errOrCloseEvent) && errOrCloseEvent.code === 1000) return locks > 0;\n    // retries are not allowed or we tried to many times, report error\n    if (!retryAttempts || retries >= retryAttempts) throw errOrCloseEvent;\n    // throw non-retryable connection problems\n    if (!shouldRetry(errOrCloseEvent)) throw errOrCloseEvent;\n    // @deprecated throw fatal connection problems immediately\n    if (isFatalConnectionProblem === null || isFatalConnectionProblem === void 0 ? void 0 : isFatalConnectionProblem(errOrCloseEvent)) throw errOrCloseEvent;\n    // looks good, start retrying\n    return retrying = true;\n  }\n  // in non-lazy (hot?) mode always hold one connection lock to persist the socket\n  if (!lazy) {\n    (async () => {\n      locks++;\n      for (;;) {\n        try {\n          const [,, throwOnClose] = await connect();\n          await throwOnClose; // will always throw because releaser is not used\n        } catch (errOrCloseEvent) {\n          try {\n            if (!shouldRetryConnectOrThrow(errOrCloseEvent)) return;\n          } catch (errOrCloseEvent) {\n            // report thrown error, no further retries\n            return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(errOrCloseEvent);\n          }\n        }\n      }\n    })();\n  }\n  return {\n    on: emitter.on,\n    subscribe(payload, sink) {\n      const id = generateID();\n      let done = false,\n        errored = false,\n        releaser = () => {\n          // for handling completions before connect\n          locks--;\n          done = true;\n        };\n      (async () => {\n        locks++;\n        for (;;) {\n          try {\n            const [socket, release, waitForReleaseOrThrowOnClose] = await connect();\n            // if done while waiting for connect, release the connection lock right away\n            if (done) return release();\n            const unlisten = emitter.onMessage(id, message => {\n              switch (message.type) {\n                case MessageType.Next:\n                  {\n                    sink.next(message.payload);\n                    return;\n                  }\n                case MessageType.Error:\n                  {\n                    errored = true, done = true;\n                    sink.error(message.payload);\n                    releaser();\n                    return;\n                  }\n                case MessageType.Complete:\n                  {\n                    done = true;\n                    releaser(); // release completes the sink\n                    return;\n                  }\n              }\n            });\n            socket.send(stringifyMessage({\n              id,\n              type: MessageType.Subscribe,\n              payload\n            }, replacer));\n            releaser = () => {\n              if (!done && socket.readyState === WebSocketImpl.OPEN)\n                // if not completed already and socket is open, send complete message to server on release\n                socket.send(stringifyMessage({\n                  id,\n                  type: MessageType.Complete\n                }, replacer));\n              locks--;\n              done = true;\n              release();\n            };\n            // either the releaser will be called, connection completed and\n            // the promise resolved or the socket closed and the promise rejected.\n            // whatever happens though, we want to stop listening for messages\n            await waitForReleaseOrThrowOnClose.finally(unlisten);\n            return; // completed, shouldnt try again\n          } catch (errOrCloseEvent) {\n            if (!shouldRetryConnectOrThrow(errOrCloseEvent)) return;\n          }\n        }\n      })().then(() => {\n        // delivering either an error or a complete terminates the sequence\n        if (!errored) sink.complete();\n      }) // resolves on release or normal closure\n      .catch(err => {\n        sink.error(err);\n      }); // rejects on close events and errors\n      return () => {\n        // dispose only of active subscriptions\n        if (!done) releaser();\n      };\n    },\n    async dispose() {\n      disposed = true;\n      if (connecting) {\n        // if there is a connection, close it\n        const [socket] = await connecting;\n        socket.close(1000, 'Normal Closure');\n      }\n    },\n    terminate() {\n      if (connecting) {\n        // only if there is a connection\n        emitter.emit('closed', {\n          code: 4499,\n          reason: 'Terminated',\n          wasClean: false\n        });\n      }\n    }\n  };\n}\nfunction isLikeCloseEvent(val) {\n  return isObject(val) && 'code' in val && 'reason' in val;\n}\nfunction isFatalInternalCloseCode(code) {\n  if ([1000, 1001, 1006, 1005, 1012, 1013, 1013 // Bad Gateway\n  ].includes(code)) return false;\n  // all other internal errors are fatal\n  return code >= 1000 && code <= 1999;\n}\nfunction isWebSocket(val) {\n  return typeof val === 'function' && 'constructor' in val && 'CLOSED' in val && 'CLOSING' in val && 'CONNECTING' in val && 'OPEN' in val;\n}","import { Observable, Subscriber } from 'rxjs';\nimport {\n  GraphQLRequestHandler,\n  GraphQLRequestOptions,\n  GraphQLResponseData,\n} from '../types';\nimport { Client, createClient } from 'graphql-ws';\nimport { simpleResponseObserver } from '../utils';\n\nexport class GraphQLWsRequestHandler implements GraphQLRequestHandler {\n  client?: Client;\n  cleanup?: () => void;\n\n  handle(request: GraphQLRequestOptions): Observable<GraphQLResponseData> {\n    return new Observable((subscriber) => {\n      this.client = createClient({\n        url: request.url,\n        connectionParams: request.additionalParams,\n        lazy: false,\n        onNonLazyError: (err) => {\n          subscriber.error(err);\n        },\n        on: {\n          error: (err) => {\n            subscriber.error(err);\n          },\n        },\n      });\n\n      if (!this.client) {\n        throw new Error('Could not create GraphQL WS client!');\n      }\n\n      const requestStartTimestamp = Date.now();\n\n      this.cleanup = this.client.subscribe(\n        {\n          query: request.query,\n          variables: request.variables,\n          operationName: request.selectedOperation ?? undefined,\n          extensions: request.extensions,\n        },\n        simpleResponseObserver(subscriber, request.url, requestStartTimestamp)\n      );\n\n      return () => {\n        this.destroy();\n      };\n    });\n  }\n\n  async destroy() {\n    try {\n      this.cleanup?.();\n      this.cleanup = undefined;\n      // This causes the 'Error: Uncaught (in promise): Event: {\"isTrusted\":true}' error\n      await this.client?.dispose();\n      this.client = undefined;\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error(err);\n    }\n  }\n}\n"],"names":["baseHasOwnProperty","isObject","val","areGraphQLErrors","obj","ob","hasOwnProperty","prop","baseHasOwnProperty","hasOwnObjectProperty","isObject","hasOwnStringProperty","obj","prop","baseHasOwnProperty","limitCloseReason","reason","whenTooLong","GRAPHQL_TRANSPORT_WS_PROTOCOL","CloseCode","MessageType","isMessage","val","isObject","hasOwnStringProperty","hasOwnProperty","hasOwnObjectProperty","areGraphQLErrors","parseMessage","data","reviver","message","stringifyMessage","msg","replacer","createClient","options","url","connectionParams","lazy","onNonLazyError","lazyCloseTimeout","keepAlive","disablePong","connectionAckWaitTimeout","retryAttempts","retryWait","retries","__async","retryDelay","i","resolve","shouldRetry","isLikeCloseEvent","isFatalConnectionProblem","on","webSocketImpl","generateID","c","r","replacer","reviver","ws","isWebSocket","WebSocketImpl","emitter","message","listeners","id","listener","_a","event","l","args","errorOrClosed","cb","listening","err","unlisten","connecting","locks","retrying","disposed","connect","socket","throwOnClose","connected","denied","GRAPHQL_TRANSPORT_WS_PROTOCOL","connectionAckTimeout","queuedPing","enqueuePing","stringifyMessage","MessageType","errOrEvent","payload","CloseCode","limitCloseReason","acknowledged","data","parseMessage","_","reject","release","released","complete","shouldRetryConnectOrThrow","errOrCloseEvent","isFatalInternalCloseCode","sink","done","errored","releaser","waitForReleaseOrThrowOnClose","val","isObject","code","GraphQLWsRequestHandler","handle","request","Observable","subscriber","client","createClient","url","connectionParams","additionalParams","lazy","onNonLazyError","err","error","on","Error","requestStartTimestamp","Date","now","cleanup","subscribe","query","variables","operationName","selectedOperation","undefined","extensions","simpleResponseObserver","destroy","__async","dispose","console"],"mappings":"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","debug_id":"86d2468e-0307-5e3f-a1db-f7e57fcc3eaf"}