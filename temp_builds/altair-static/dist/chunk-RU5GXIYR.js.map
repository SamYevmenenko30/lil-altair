{"version":3,"sources":["src/app/modules/altair/services/gql/generateQuery.ts","src/app/modules/altair/services/gql/helpers.ts","src/app/modules/altair/services/gql/prettifier.ts","src/app/modules/altair/utils/get-root-types.ts"],"sourcesContent":["import {\n  ArgumentNode,\n  astFromValue,\n  DocumentNode,\n  FragmentDefinitionNode,\n  getNamedType,\n  GraphQLBoolean,\n  GraphQLEnumType,\n  GraphQLField,\n  GraphQLInputObjectType,\n  GraphQLInputType,\n  GraphQLInt,\n  GraphQLInterfaceType,\n  GraphQLObjectType,\n  GraphQLSchema,\n  GraphQLString,\n  GraphQLType,\n  isInputObjectType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n  isRequiredInputField,\n  Kind,\n  ObjectFieldNode,\n  OperationDefinitionNode,\n  OperationTypeNode,\n  print,\n  SelectionSetNode,\n  ValueNode,\n} from 'graphql';\nimport { Maybe } from 'graphql/jsutils/Maybe';\nimport { getTypeName } from './helpers';\nimport { prettify } from './prettifier';\n\ninterface GenerateMeta {\n  hasArgs?: boolean;\n}\n\nexport const generateQuery = async (\n  schema: GraphQLSchema,\n  name: string,\n  parentType: string,\n  { maxDepth = 2, tabSize = 2 } = {}\n) => {\n  const parentTypeObject = schema.getType(parentType);\n\n  if (!(parentTypeObject instanceof GraphQLObjectType)) {\n    return { generated: '', metas: [] };\n  }\n  const field = parentTypeObject.getFields()[name];\n\n  if (!field) {\n    return { generated: '', metas: [] };\n  }\n\n  const operationType = getOperationType(schema, parentTypeObject);\n\n  const { node: selectionNode, metas } = buildSelectionNode(field, {\n    maxDepth,\n    currentDepth: 0,\n  });\n  const selectionSet = {\n    kind: Kind.SELECTION_SET,\n    // start building actual content here\n    selections: [selectionNode],\n  };\n\n  const x: DocumentNode = {\n    kind: Kind.DOCUMENT,\n    definitions: [\n      operationType\n        ? buildOperationDefinitionWrapper(operationType, selectionSet)\n        : buildFragmentDefinitionWrapper(parentTypeObject, selectionSet),\n    ],\n  };\n\n  return {\n    generated: await prettify(print(x), tabSize),\n    metas,\n  };\n};\n\nconst getOperationType = (schema: GraphQLSchema, type: GraphQLObjectType) => {\n  const typeToOperation = new Map<\n    Maybe<GraphQLObjectType<any, any>>,\n    OperationTypeNode\n  >([\n    [schema.getQueryType(), 'query'],\n    [schema.getMutationType(), 'mutation'],\n    [schema.getSubscriptionType(), 'subscription'],\n  ]);\n\n  return typeToOperation.get(type);\n};\n\n// operation definition would wrap a selection to return a query AST (for fields from root types)\nconst buildOperationDefinitionWrapper = (\n  operationType: OperationTypeNode,\n  selectionSet: SelectionSetNode\n): OperationDefinitionNode => {\n  return {\n    kind: Kind.OPERATION_DEFINITION,\n    operation: operationType,\n    name: undefined,\n    variableDefinitions: [],\n    directives: [],\n    selectionSet,\n  };\n};\n\n// fragment definition would wrap a selection to return a fragment AST\nconst buildFragmentDefinitionWrapper = (\n  parentType: GraphQLObjectType,\n  selectionSet: SelectionSetNode\n): FragmentDefinitionNode => {\n  return {\n    kind: Kind.FRAGMENT_DEFINITION,\n    name: {\n      kind: Kind.NAME,\n      value: '____',\n    },\n    variableDefinitions: [],\n    directives: [],\n    typeCondition: {\n      kind: Kind.NAMED_TYPE,\n      name: {\n        kind: Kind.NAME,\n        value: parentType.name,\n      },\n    },\n    selectionSet,\n  };\n};\n\nexport const buildSelectionSet = (\n  type: GraphQLType | null,\n  { maxDepth = 1, currentDepth = 0 } = {}\n): { selectionSet: SelectionSetNode; metas: GenerateMeta[] } => {\n  let setMetas: GenerateMeta[] = [];\n  const selectionSet: SelectionSetNode = {\n    kind: Kind.SELECTION_SET,\n    selections: [],\n  };\n\n  if (!type) {\n    return { selectionSet, metas: setMetas };\n  }\n  const namedType = getNamedType(type);\n\n  if (\n    !(\n      namedType instanceof GraphQLObjectType ||\n      namedType instanceof GraphQLInterfaceType\n    )\n  ) {\n    return { selectionSet, metas: setMetas };\n  }\n\n  if (isLeafType(type)) {\n    return { selectionSet, metas: setMetas };\n  }\n\n  if (currentDepth >= maxDepth) {\n    return { selectionSet, metas: setMetas };\n  }\n\n  const fields = namedType && namedType.getFields();\n  selectionSet.selections = Object.entries(fields).map(([, field]) => {\n    const { node, metas } = buildSelectionNode(field, {\n      maxDepth,\n      currentDepth,\n    });\n\n    setMetas = [...setMetas, ...metas];\n\n    return node;\n  });\n\n  return { selectionSet, metas: setMetas };\n};\n\nexport const buildSelectionNode = (\n  field: GraphQLField<any, any>,\n  { maxDepth = 1, currentDepth = 0 } = {}\n) => {\n  const argumentsNodes: ArgumentNode[] = field.args.map((arg) => {\n    return {\n      kind: Kind.ARGUMENT,\n      name: {\n        kind: Kind.NAME,\n        value: arg.name,\n      },\n      value: buildDefaultArgumentValueNode(arg.type, arg.defaultValue),\n    };\n  });\n\n  const { selectionSet, metas } = buildSelectionSet(field.type, {\n    maxDepth,\n    currentDepth: currentDepth + 1,\n  });\n\n  const node = {\n    kind: Kind.FIELD,\n    alias: undefined,\n    name: {\n      kind: Kind.NAME,\n      value: field.name,\n    },\n    arguments: argumentsNodes,\n    directives: [],\n    selectionSet,\n  } as const;\n\n  return { node, metas: [{ hasArgs: !!argumentsNodes.length }, ...metas] };\n};\n\n// Generate default values based on the GraphQL type\nconst buildDefaultArgumentValueNode = (\n  argumentType: GraphQLInputType,\n  defaultValue?: unknown,\n  { currentDepth = 0, maxDepth = 2 } = {}\n): ValueNode => {\n  return (\n    maybeBuildDefaultArgumentValueNode(argumentType, defaultValue, {\n      currentDepth,\n      maxDepth,\n    }) ?? { kind: Kind.STRING, value: '_____' }\n  );\n};\nconst maybeBuildDefaultArgumentValueNode = (\n  type: GraphQLInputType,\n  defaultValue?: unknown,\n  { currentDepth = 0, maxDepth = 2 } = {}\n): ValueNode | undefined | null => {\n  const defaultValueNode = astFromValue(defaultValue, type);\n  if (defaultValueNode) {\n    return defaultValueNode;\n  }\n\n  if (isNonNullType(type)) {\n    type = type.ofType;\n  }\n\n  // handle lists\n  if (isListType(type)) {\n    const value: ValueNode = {\n      kind: Kind.LIST,\n      values: [\n        buildDefaultArgumentValueNode(type.ofType, undefined, {\n          currentDepth: currentDepth + 1,\n          maxDepth,\n        }),\n      ],\n    };\n    return value;\n  }\n\n  // handle complex objects\n  if (isObjectType(type) || isInputObjectType(type)) {\n    if (currentDepth >= maxDepth) {\n      return;\n    }\n\n    const fieldNodes: ObjectFieldNode[] = [];\n    for (const field of Object.values(\n      (type as GraphQLInputObjectType).getFields()\n    )) {\n      if (isRequiredInputField(field)) {\n        const fieldValue = maybeBuildDefaultArgumentValueNode(\n          field.type,\n          undefined,\n          { currentDepth: currentDepth + 1, maxDepth }\n        );\n        if (fieldValue) {\n          fieldNodes.push({\n            kind: Kind.OBJECT_FIELD,\n            name: { kind: Kind.NAME, value: field.name },\n            value: fieldValue,\n          });\n        }\n      }\n    }\n    return { kind: Kind.OBJECT, fields: fieldNodes };\n  }\n\n  if (type instanceof GraphQLEnumType) {\n    const defaultValue = type.getValues()[0];\n\n    if (!defaultValue) {\n      return;\n    }\n\n    return astFromValue(defaultValue.name, type);\n  }\n\n  const typeName = getTypeName(type);\n\n  switch (typeName) {\n    case 'String': {\n      return astFromValue('string', GraphQLString);\n    }\n    case 'Boolean': {\n      return astFromValue(true, GraphQLBoolean);\n    }\n    case 'Int': {\n      return astFromValue(1, GraphQLInt);\n    }\n  }\n};\n","import {\n  GraphQLType,\n  GraphQLSchema,\n  FragmentDefinitionNode,\n  GraphQLFieldMap,\n  TypeInfo,\n  visitWithTypeInfo,\n  visit,\n  DocumentNode,\n  getNamedType,\n  FieldNode,\n  Visitor,\n  isLeafType,\n  ArgumentNode,\n  ValueNode,\n  valueFromASTUntyped,\n  Kind,\n} from 'graphql';\nimport { IDictionary } from '../../interfaces/shared';\nimport { debug } from '../../utils/logger';\n\n/**\nRefactor query:\n\n- Name queries\n\n- Factor out common fields to fragment\n\n= Find all types in query that are not leaf types\n= Create a tree of types\n= Filter out types used more than once\nFind fields from those types (leaf fields only for now)\nFilter out fields used more than once\nIf fields are up to 2, create a fragment containing the common fields\nRemove common fields from original queries\nAdd fragment in place of common fields\n\n */\n\ninterface TypeUsageMapEntry {\n  name: string;\n  count: number;\n  type?: GraphQLType;\n  fields: string[][];\n  children: IDictionary<TypeUsageMapEntry>;\n}\n\ntype FragmentRefactorMap = IDictionary<string[]>;\n\nexport const generateRandomNameForString = (value: string) =>\n  value\n    .trim()\n    .replace(/[^A-Za-z0-9]/g, '_')\n    .replace(/_+/g, '_')\n    .substr(0, 20) + (Math.random() * 1000).toFixed(0);\n\nexport const getTypeName = (type: GraphQLType) => getNamedType(type).toString();\n\nexport const getRefactoredFragmentName = (typeName: string) => `${typeName}Fields`;\n\nexport const getFragmentSpreadNode = (name: string) => {\n  return {\n    kind: Kind.FRAGMENT_SPREAD,\n    name: {\n      kind: Kind.NAME,\n      value: name,\n    },\n  };\n};\n\nexport const getFragmentDefinitionFromRefactorMap = (\n  refactorMap: FragmentRefactorMap,\n  schema: GraphQLSchema\n): FragmentDefinitionNode[] => {\n  return Object.entries(refactorMap).map(([typeName, fieldList]) => {\n    const type = schema.getType(typeName);\n    const fieldsMap: GraphQLFieldMap<any, any> = type && (type as any).getFields();\n\n    return {\n      kind: Kind.FRAGMENT_DEFINITION,\n      name: {\n        kind: Kind.NAME,\n        value: getRefactoredFragmentName(typeName),\n      },\n      typeCondition: {\n        kind: Kind.NAMED_TYPE,\n        name: {\n          kind: Kind.NAME,\n          value: typeName,\n        },\n      },\n      selectionSet: {\n        kind: Kind.SELECTION_SET,\n        selections: fieldList.map((field) => {\n          const fieldValue = fieldsMap && fieldsMap[field];\n          return {\n            kind: Kind.FIELD,\n            name: {\n              kind: Kind.NAME,\n              value: field,\n            },\n            type: fieldValue ? fieldValue.type.inspect() : '',\n          };\n        }),\n      },\n    };\n  });\n};\n\n/**\n * Replaces fields matching the given refactor map with the equivalent fragment spread\n * Note: This doesn't generate the fragment. Only generates the fragment spread within the queries\n */\nexport const refactorFieldsWithFragmentSpread = (\n  ast: DocumentNode,\n  refactorMap: FragmentRefactorMap,\n  schema: GraphQLSchema\n) => {\n  const typeInfo = new TypeInfo(schema);\n  const edited = visit(\n    ast,\n    visitWithTypeInfo(typeInfo, {\n      Field: {\n        enter(node) {\n          typeInfo.enter(node);\n          const type = typeInfo.getType();\n          if (type) {\n            const typeName = getTypeName(type);\n            const refactorFields = refactorMap[typeName];\n            if (\n              refactorFields &&\n              node.selectionSet &&\n              refactorFields.every(\n                (field) =>\n                  !!node.selectionSet!.selections.find(\n                    (selection) =>\n                      'name' in selection && selection.name.value === field\n                  )\n              )\n            ) {\n              return {\n                ...node,\n                selectionSet: {\n                  ...node.selectionSet,\n                  selections: [\n                    ...node.selectionSet.selections.filter(\n                      (selection) =>\n                        'name' in selection &&\n                        !refactorFields.includes(selection.name.value)\n                    ),\n                    getFragmentSpreadNode(getRefactoredFragmentName(typeName)),\n                  ],\n                },\n              };\n            }\n          }\n        },\n        leave(node) {\n          typeInfo.leave(node);\n        },\n      },\n    })\n  );\n\n  return edited;\n};\n\n/**\n * Gathers usage information of all the object types (doesn't consider primitives/leaf types)\n * that are found in the given document node\n */\nexport const generateTypeUsageEntries = (\n  ast: DocumentNode,\n  schema: GraphQLSchema\n) => {\n  const typeInfo = new TypeInfo(schema);\n  const typeTree: TypeUsageMapEntry = {\n    name: 'root',\n    count: 0,\n    fields: [],\n    children: {},\n  };\n  const typesMap: IDictionary<TypeUsageMapEntry> = {\n    root: typeTree,\n  };\n\n  function createTypeMapEntry(type: GraphQLType) {\n    const namedType = getNamedType(type);\n    const namedTypeStr = namedType.toString();\n    const res = (typesMap[namedTypeStr] ||= {\n      name: namedTypeStr,\n      count: 0,\n      type: namedType,\n      fields: [],\n      children: {},\n    });\n\n    return res;\n  }\n\n  const innerVisitor: Visitor<any> = {\n    enter(node) {\n      typeInfo.enter(node);\n      const type = typeInfo.getType();\n      node.type = type;\n      if (type && !isLeafType(getNamedType(type))) {\n        // debug.log('REFACTOR', node, typeInfo.getFieldDef() && typeInfo.getFieldDef().name, typeInfo.getParentType());\n\n        const typeMapEntry = createTypeMapEntry(type);\n        typeMapEntry.count++;\n        if (node.selectionSet && node.selectionSet.selections) {\n          const currentNodeFields = node.selectionSet.selections\n            // Only consider leaf fields for refactoring (not nested fields)\n            .filter(\n              (selection: any) =>\n                !selection.selectionSet || !selection.selectionSet.selections\n            )\n            // Only consider fields\n            .filter((selection: any) => selection.kind === Kind.FIELD)\n            .filter((selection: any) => selection.name && selection.name.value)\n            .map((selection: any) => selection.name && selection.name.value)\n            .filter(Boolean);\n          typeMapEntry.fields.push(currentNodeFields);\n        }\n        // Get parent type\n        // Add parent type to map\n        // Add field type as child of parent type in map\n        const parentType = typeInfo.getParentType();\n        if (parentType) {\n          const parentTypeMapEntry = createTypeMapEntry(parentType);\n          parentTypeMapEntry.children[typeMapEntry.name] = typeMapEntry;\n        } else {\n          typeTree.children[typeMapEntry.name] = typeMapEntry;\n        }\n      }\n      return node;\n    },\n    leave(node) {\n      typeInfo.leave(node);\n    },\n  };\n\n  const visitor: any = {\n    OperationDefinition: innerVisitor,\n    Field: innerVisitor,\n  };\n  visit(ast, visitWithTypeInfo(typeInfo, visitor));\n\n  return {\n    map: typesMap,\n    tree: typeTree,\n  };\n};\n\n/**\n * Generate a mapping of types (that meet criteria) to a list\n * of common field names that can be refactored into a fragment\n */\nexport const generateFragmentRefactorMap = (typeUsageEntries: {\n  map: IDictionary<TypeUsageMapEntry>;\n  tree: TypeUsageMapEntry;\n}) => {\n  /*\n     Walk through the type tree to find the types that meets the criteria:\n     - count >= 2\n     - matching fields >= 2\n\n     Considering that we would only consider leaf fields at the moment,\n     we can simply look through all the types in the type map that match the criteria.\n\n     In the future when object types are also considered as part of the fragmentation refactoring,\n     we would need to only consider the first set of types in the tree that meet the criteria\n     and not consider the types in sub levels of the tree.\n     */\n  const fragmentRefactorMap: FragmentRefactorMap = {};\n  Object.values(typeUsageEntries.map).forEach((typeMap) => {\n    if (typeMap.count >= 2) {\n      if (typeMap.fields.length) {\n        typeMap.fields[0]?.forEach((field) => {\n          if (typeMap.fields.slice(1).every((list) => list.includes(field))) {\n            const fieldList = (fragmentRefactorMap[typeMap.name] ||= []);\n            fieldList.push(field);\n          }\n        });\n      }\n    }\n  });\n\n  return fragmentRefactorMap;\n};\n\n/**\n * Adds Fragment definitions to the document corresponding to the given refactor map\n */\nexport const addFragmentDefinitionFromRefactorMap = (\n  ast: DocumentNode,\n  refactorMap: FragmentRefactorMap,\n  schema: GraphQLSchema\n) => {\n  return visit(ast, {\n    Document(node) {\n      return {\n        ...node,\n        definitions: node.definitions.concat(\n          getFragmentDefinitionFromRefactorMap(refactorMap, schema)\n        ),\n      };\n    },\n  });\n};\n\nconst argumentValueToJS = (argValue: ValueNode, variables?: IDictionary) => {\n  return valueFromASTUntyped(argValue, variables);\n};\n\nconst argumentNodeToJS = (argumentNode: ArgumentNode, variables?: IDictionary) => {\n  return argumentValueToJS(argumentNode.value, variables);\n};\n\nexport const refactorArgumentsToVariables = (\n  ast: DocumentNode,\n  schema: GraphQLSchema,\n  variables?: IDictionary\n) => {\n  interface VariableMapEntry {\n    name: string;\n    value: any;\n    type: string;\n  }\n  const variablesMap: IDictionary<VariableMapEntry> = {};\n  let variablesPipeline: VariableMapEntry[] = [];\n\n  // Get complex arguments, replacing them with variables and creating a variables map at the same time\n  // Filter out same variables\n  // Return stripped out query and unique variables\n  // refactorArgumentsToVariables\n  const typeInfo = new TypeInfo(schema);\n  const edited = visit(ast, {\n    enter(node) {\n      typeInfo.enter(node);\n      switch (node.kind) {\n        case Kind.ARGUMENT:\n          {\n            const fieldDef = typeInfo.getFieldDef();\n            if (node.value.kind !== Kind.VARIABLE && fieldDef && fieldDef.args) {\n              const foundArg = fieldDef.args.find(\n                (arg) => arg.name === node.name.value\n              );\n              if (foundArg) {\n                let variableName = foundArg.name;\n                if (variablesMap[variableName]) {\n                  // variable name is already used, so generate random name instead\n                  variableName = generateRandomNameForString(foundArg.name);\n                }\n                const variableMapEntry = {\n                  name: variableName,\n                  value: argumentNodeToJS(node, variables),\n                  type: foundArg.type.inspect(),\n                };\n                variablesMap[variableName] = variableMapEntry;\n                variablesPipeline.push(variableMapEntry);\n                return {\n                  ...node,\n                  value: {\n                    kind: Kind.VARIABLE,\n                    name: {\n                      kind: Kind.NAME,\n                      value: variableName,\n                    },\n                  },\n                };\n              }\n            }\n          }\n          break;\n      }\n    },\n    leave(node) {\n      typeInfo.leave(node);\n      switch (node.kind) {\n        case Kind.OPERATION_DEFINITION: {\n          // debug.log('REFACTOR', variablesPipeline);\n          const newNode = {\n            ...node,\n            variableDefinitions: (node.variableDefinitions || []).concat(\n              variablesPipeline.map((variableMapEntry) => {\n                return {\n                  kind: Kind.VARIABLE_DEFINITION,\n                  variable: {\n                    kind: Kind.VARIABLE,\n                    name: {\n                      kind: Kind.NAME,\n                      value: variableMapEntry.name,\n                    },\n                  },\n                  type: {\n                    kind: Kind.NAMED_TYPE,\n                    name: {\n                      kind: Kind.NAME,\n                      value: variableMapEntry.type,\n                    },\n                  },\n                };\n              })\n            ),\n          };\n          // Set operation name if none exists\n          const nameKind = node.name || {\n            kind: Kind.NAME,\n            value: generateRandomNameForString('refactored'),\n          };\n          newNode.name = nameKind;\n          variablesPipeline = [];\n          return newNode;\n        }\n      }\n    },\n  });\n  return {\n    document: edited,\n    variables: Object.entries(variablesMap).reduce(\n      (result: IDictionary, [variableName, res]) => {\n        result[variableName] = res.value;\n        return result;\n      },\n      {}\n    ),\n  };\n};\n\n// Cleans out getType() names to contain only the type name itself\nexport const cleanTypeName = (name: string) => name.replace(/[[\\]!]/g, '');\n","export const prettify = async (query: string, tabWidth = 2) => {\n  const prettier = await import('prettier/standalone');\n  const prettierGraphql = await import('prettier/plugins/graphql');\n  // return print(parse(query));\n  return prettier.format(query, {\n    parser: 'graphql',\n    plugins: [prettierGraphql],\n    tabWidth,\n  });\n};\n","import { GraphQLSchema, GraphQLObjectType } from 'graphql';\n\nexport default (schema: GraphQLSchema) => {\n  return [\n    schema.getQueryType(),\n    schema.getMutationType(),\n    schema.getSubscriptionType(),\n  ].filter(Boolean) as GraphQLObjectType[];\n};\n"],"names":["init_graphql","init_graphql","generateRandomNameForString","value","trim","replace","substr","Math","random","toFixed","getTypeName","type","getNamedType","toString","getRefactoredFragmentName","typeName","getFragmentSpreadNode","name","kind","Kind","FRAGMENT_SPREAD","NAME","getFragmentDefinitionFromRefactorMap","refactorMap","schema","Object","entries","map","fieldList","getType","fieldsMap","getFields","FRAGMENT_DEFINITION","typeCondition","NAMED_TYPE","selectionSet","SELECTION_SET","selections","field","fieldValue","FIELD","inspect","refactorFieldsWithFragmentSpread","ast","typeInfo","TypeInfo","visit","visitWithTypeInfo","Field","enter","node","refactorFields","every","find","selection","__spreadProps","__spreadValues","filter","includes","leave","generateTypeUsageEntries","typeTree","count","fields","children","typesMap","root","createTypeMapEntry","namedType","namedTypeStr","innerVisitor","isLeafType","typeMapEntry","currentNodeFields","Boolean","push","parentType","getParentType","parentTypeMapEntry","OperationDefinition","tree","generateFragmentRefactorMap","typeUsageEntries","fragmentRefactorMap","values","forEach","typeMap","length","slice","list","addFragmentDefinitionFromRefactorMap","Document","definitions","concat","argumentValueToJS","argValue","variables","valueFromASTUntyped","argumentNodeToJS","argumentNode","refactorArgumentsToVariables","variablesMap","variablesPipeline","document","ARGUMENT","fieldDef","getFieldDef","VARIABLE","args","foundArg","arg","variableName","variableMapEntry","OPERATION_DEFINITION","newNode","variableDefinitions","VARIABLE_DEFINITION","variable","nameKind","reduce","result","res","cleanTypeName","prettify","query","tabWidth","__async","prettier","prettierGraphql","format","parser","plugins","generateQuery","schema","name","parentType","_3","__async","maxDepth","tabSize","parentTypeObject","getType","GraphQLObjectType","generated","metas","field","getFields","operationType","getOperationType","node","selectionNode","buildSelectionNode","currentDepth","selectionSet","kind","Kind","SELECTION_SET","selections","x","DOCUMENT","definitions","buildOperationDefinitionWrapper","buildFragmentDefinitionWrapper","prettify","print","type","Map","getQueryType","getMutationType","getSubscriptionType","get","OPERATION_DEFINITION","operation","undefined","variableDefinitions","directives","FRAGMENT_DEFINITION","NAME","value","typeCondition","NAMED_TYPE","buildSelectionSet","setMetas","namedType","getNamedType","GraphQLInterfaceType","isLeafType","fields","Object","entries","map","argumentsNodes","args","arg","ARGUMENT","buildDefaultArgumentValueNode","defaultValue","FIELD","alias","arguments","hasArgs","length","argumentType","maybeBuildDefaultArgumentValueNode","STRING","defaultValueNode","astFromValue","isNonNullType","ofType","isListType","LIST","values","isObjectType","isInputObjectType","fieldNodes","isRequiredInputField","fieldValue","push","OBJECT_FIELD","OBJECT","GraphQLEnumType","getValues","getTypeName","GraphQLString","GraphQLBoolean","GraphQLInt","get_root_types_default","schema","getQueryType","getMutationType","getSubscriptionType","filter","Boolean"],"mappings":";;8QAAAA,ICAAC,IAiDO,IAAMC,EAA+BC,GAC1CA,EACGC,KAAI,EACJC,QAAQ,gBAAiB,GAAG,EAC5BA,QAAQ,MAAO,GAAG,EAClBC,OAAO,EAAG,EAAE,GAAKC,KAAKC,OAAM,EAAK,KAAMC,QAAQ,CAAC,EAExCC,EAAeC,GAAsBC,EAAaD,CAAI,EAAEE,SAAQ,EAEhEC,EAA6BC,GAAqB,GAAGA,CAAQ,SAE7DC,EAAyBC,IAC7B,CACLC,KAAMC,EAAKC,gBACXH,KAAM,CACJC,KAAMC,EAAKE,KACXlB,MAAOc,KAKAK,EAAuCA,CAClDC,EACAC,IAEOC,OAAOC,QAAQH,CAAW,EAAEI,IAAI,CAAC,CAACZ,EAAUa,CAAS,IAAK,CAC/D,IAAMjB,EAAOa,EAAOK,QAAQd,CAAQ,EAC9Be,EAAuCnB,GAASA,EAAaoB,UAAS,EAE5E,MAAO,CACLb,KAAMC,EAAKa,oBACXf,KAAM,CACJC,KAAMC,EAAKE,KACXlB,MAAOW,EAA0BC,CAAQ,GAE3CkB,cAAe,CACbf,KAAMC,EAAKe,WACXjB,KAAM,CACJC,KAAMC,EAAKE,KACXlB,MAAOY,IAGXoB,aAAc,CACZjB,KAAMC,EAAKiB,cACXC,WAAYT,EAAUD,IAAKW,GAAS,CAClC,IAAMC,EAAaT,GAAaA,EAAUQ,CAAK,EAC/C,MAAO,CACLpB,KAAMC,EAAKqB,MACXvB,KAAM,CACJC,KAAMC,EAAKE,KACXlB,MAAOmC,GAET3B,KAAM4B,EAAaA,EAAW5B,KAAK8B,QAAO,EAAK,GAEnD,CAAC,GAGP,CAAC,EAOUC,GAAmCA,CAC9CC,EACApB,EACAC,IACE,CACF,IAAMoB,EAAW,IAAIC,EAASrB,CAAM,EA8CpC,OA7CesB,EACbH,EACAI,EAAkBH,EAAU,CAC1BI,MAAO,CACLC,MAAMC,EAAI,CACRN,EAASK,MAAMC,CAAI,EACnB,IAAMvC,EAAOiC,EAASf,QAAO,EAC7B,GAAIlB,EAAM,CACR,IAAMI,EAAWL,EAAYC,CAAI,EAC3BwC,EAAiB5B,EAAYR,CAAQ,EAC3C,GACEoC,GACAD,EAAKf,cACLgB,EAAeC,MACZd,GACC,CAAC,CAACY,EAAKf,aAAcE,WAAWgB,KAC7BC,GACC,SAAUA,GAAaA,EAAUrC,KAAKd,QAAUmC,CAAK,CACxD,EAGL,OAAOiB,EAAAC,EAAA,GACFN,GADE,CAELf,aAAcoB,EAAAC,EAAA,GACTN,EAAKf,cADI,CAEZE,WAAY,CACV,GAAGa,EAAKf,aAAaE,WAAWoB,OAC7BH,GACC,SAAUA,GACV,CAACH,EAAeO,SAASJ,EAAUrC,KAAKd,KAAK,CAAC,EAElDa,EAAsBF,EAA0BC,CAAQ,CAAC,CAAC,KAKpE,CACF,EACA4C,MAAMT,EAAI,CACRN,EAASe,MAAMT,CAAI,CACrB,GAEH,CAAC,CAIN,EAMaU,GAA2BA,CACtCjB,EACAnB,IACE,CACF,IAAMoB,EAAW,IAAIC,EAASrB,CAAM,EAC9BqC,EAA8B,CAClC5C,KAAM,OACN6C,MAAO,EACPC,OAAQ,CAAA,EACRC,SAAU,CAAA,GAENC,EAA2C,CAC/CC,KAAML,GAGR,SAASM,EAAmBxD,EAAiB,CAC3C,IAAMyD,EAAYxD,EAAaD,CAAI,EAC7B0D,EAAeD,EAAUvD,SAAQ,EASvC,OARaoD,EAASI,CAAY,IAAM,CACtCpD,KAAMoD,EACNP,MAAO,EACPnD,KAAMyD,EACNL,OAAQ,CAAA,EACRC,SAAU,CAAA,EAId,CAEA,IAAMM,EAA6B,CACjCrB,MAAMC,EAAI,CACRN,EAASK,MAAMC,CAAI,EACnB,IAAMvC,EAAOiC,EAASf,QAAO,EAE7B,GADAqB,EAAKvC,KAAOA,EACRA,GAAQ,CAAC4D,EAAW3D,EAAaD,CAAI,CAAC,EAAG,CAG3C,IAAM6D,EAAeL,EAAmBxD,CAAI,EAE5C,GADA6D,EAAaV,QACTZ,EAAKf,cAAgBe,EAAKf,aAAaE,WAAY,CACrD,IAAMoC,EAAoBvB,EAAKf,aAAaE,WAEzCoB,OACEH,GACC,CAACA,EAAUnB,cAAgB,CAACmB,EAAUnB,aAAaE,UAAU,EAGhEoB,OAAQH,GAAmBA,EAAUpC,OAASC,EAAKqB,KAAK,EACxDiB,OAAQH,GAAmBA,EAAUrC,MAAQqC,EAAUrC,KAAKd,KAAK,EACjEwB,IAAK2B,GAAmBA,EAAUrC,MAAQqC,EAAUrC,KAAKd,KAAK,EAC9DsD,OAAOiB,OAAO,EACjBF,EAAaT,OAAOY,KAAKF,CAAiB,CAC5C,CAIA,IAAMG,EAAahC,EAASiC,cAAa,EACzC,GAAID,EAAY,CACd,IAAME,EAAqBX,EAAmBS,CAAU,EACxDE,EAAmBd,SAASQ,EAAavD,IAAI,EAAIuD,CACnD,MACEX,EAASG,SAASQ,EAAavD,IAAI,EAAIuD,CAE3C,CACA,OAAOtB,CACT,EACAS,MAAMT,EAAI,CACRN,EAASe,MAAMT,CAAI,CACrB,GAOFJ,OAAAA,EAAMH,EAAKI,EAAkBH,EAJR,CACnBmC,oBAAqBT,EACrBtB,MAAOsB,EAEqC,CAAC,EAExC,CACL3C,IAAKsC,EACLe,KAAMnB,EAEV,EAMaoB,GAA+BC,GAGvC,CAaH,IAAMC,EAA2C,CAAA,EACjD1D,cAAO2D,OAAOF,EAAiBvD,GAAG,EAAE0D,QAASC,GAAW,CAClDA,EAAQxB,OAAS,GACfwB,EAAQvB,OAAOwB,QACjBD,EAAQvB,OAAO,CAAC,GAAGsB,QAAS/C,GAAS,CAC/BgD,EAAQvB,OAAOyB,MAAM,CAAC,EAAEpC,MAAOqC,GAASA,EAAK/B,SAASpB,CAAK,CAAC,IAC3C6C,EAAoBG,EAAQrE,IAAI,IAAM,CAAA,GAC/C0D,KAAKrC,CAAK,CAExB,CAAC,CAGP,CAAC,EAEM6C,CACT,EAKaO,GAAuCA,CAClD/C,EACApB,EACAC,IAEOsB,EAAMH,EAAK,CAChBgD,SAASzC,EAAI,CACX,OAAOK,EAAAC,EAAA,GACFN,GADE,CAEL0C,YAAa1C,EAAK0C,YAAYC,OAC5BvE,EAAqCC,EAAaC,CAAM,CAAC,GAG/D,EACD,EAGGsE,EAAoBA,CAACC,EAAqBC,IACvCC,EAAoBF,EAAUC,CAAS,EAG1CE,EAAmBA,CAACC,EAA4BH,IAC7CF,EAAkBK,EAAahG,MAAO6F,CAAS,EAG3CI,GAA+BA,CAC1CzD,EACAnB,EACAwE,IACE,CAMF,IAAMK,EAA8C,CAAA,EAChDC,EAAwC,CAAA,EAMtC1D,EAAW,IAAIC,EAASrB,CAAM,EAkFpC,MAAO,CACL+E,SAlFazD,EAAMH,EAAK,CACxBM,MAAMC,EAAI,CAER,OADAN,EAASK,MAAMC,CAAI,EACXA,EAAKhC,KAAI,CACf,KAAKC,EAAKqF,SACR,CACE,IAAMC,EAAW7D,EAAS8D,YAAW,EACrC,GAAIxD,EAAK/C,MAAMe,OAASC,EAAKwF,UAAYF,GAAYA,EAASG,KAAM,CAClE,IAAMC,EAAWJ,EAASG,KAAKvD,KAC5ByD,GAAQA,EAAI7F,OAASiC,EAAKjC,KAAKd,KAAK,EAEvC,GAAI0G,EAAU,CACZ,IAAIE,EAAeF,EAAS5F,KACxBoF,EAAaU,CAAY,IAE3BA,EAAe7G,EAA4B2G,EAAS5F,IAAI,GAE1D,IAAM+F,EAAmB,CACvB/F,KAAM8F,EACN5G,MAAO+F,EAAiBhD,EAAM8C,CAAS,EACvCrF,KAAMkG,EAASlG,KAAK8B,QAAO,GAE7B4D,OAAAA,EAAaU,CAAY,EAAIC,EAC7BV,EAAkB3B,KAAKqC,CAAgB,EAChCzD,EAAAC,EAAA,GACFN,GADE,CAEL/C,MAAO,CACLe,KAAMC,EAAKwF,SACX1F,KAAM,CACJC,KAAMC,EAAKE,KACXlB,MAAO4G,KAIf,CACF,CACF,CACA,KACJ,CACF,EACApD,MAAMT,EAAI,CAER,OADAN,EAASe,MAAMT,CAAI,EACXA,EAAKhC,KAAI,CACf,KAAKC,EAAK8F,qBAAsB,CAE9B,IAAMC,EAAU3D,EAAAC,EAAA,GACXN,GADW,CAEdiE,qBAAsBjE,EAAKiE,qBAAuB,CAAA,GAAItB,OACpDS,EAAkB3E,IAAKqF,IACd,CACL9F,KAAMC,EAAKiG,oBACXC,SAAU,CACRnG,KAAMC,EAAKwF,SACX1F,KAAM,CACJC,KAAMC,EAAKE,KACXlB,MAAO6G,EAAiB/F,OAG5BN,KAAM,CACJO,KAAMC,EAAKe,WACXjB,KAAM,CACJC,KAAMC,EAAKE,KACXlB,MAAO6G,EAAiBrG,QAI/B,CAAC,IAIA2G,EAAWpE,EAAKjC,MAAQ,CAC5BC,KAAMC,EAAKE,KACXlB,MAAOD,EAA4B,YAAY,GAEjDgH,OAAAA,EAAQjG,KAAOqG,EACfhB,EAAoB,CAAA,EACbY,CACT,CACF,CACF,EACD,EAGClB,UAAWvE,OAAOC,QAAQ2E,CAAY,EAAEkB,OACtC,CAACC,EAAqB,CAACT,EAAcU,CAAG,KACtCD,EAAOT,CAAY,EAAIU,EAAItH,MACpBqH,GAET,CAAA,CAAE,EAGR,EAGaE,GAAiBzG,GAAiBA,EAAKZ,QAAQ,UAAW,EAAE,EC/alE,IAAMsH,EAAW,CAAOC,EAAeC,EAAW,IAAKC,EAAA,sBAC5D,IAAMC,EAAW,KAAM,QAAO,qBAAqB,EAC7CC,EAAkB,KAAM,QAAO,qBAA0B,EAE/D,OAAOD,EAASE,OAAOL,EAAO,CAC5BM,OAAQ,UACRC,QAAS,CAACH,CAAe,EACzBH,SAAAA,EACD,CACH,GF8BO,IAAMO,GAAgB,CAC3BC,EACAC,EACAC,KAEEC,IAAAC,EAAA,MAJFJ,EACAC,EACAC,EAEE,GAAAC,GAAA,UAJFH,EACAC,EACAC,EACA,CAAEG,SAAAA,EAAW,EAAGC,QAAAA,EAAU,CAAC,EAAK,CAAA,EAC9B,CACF,IAAMC,EAAmBP,EAAOQ,QAAQN,CAAU,EAElD,GAAI,EAAEK,aAA4BE,GAChC,MAAO,CAAEC,UAAW,GAAIC,MAAO,CAAA,CAAE,EAEnC,IAAMC,EAAQL,EAAiBM,UAAS,EAAGZ,CAAI,EAE/C,GAAI,CAACW,EACH,MAAO,CAAEF,UAAW,GAAIC,MAAO,CAAA,CAAE,EAGnC,IAAMG,EAAgBC,EAAiBf,EAAQO,CAAgB,EAEzD,CAAES,KAAMC,EAAeN,MAAAA,CAAK,EAAKO,EAAmBN,EAAO,CAC/DP,SAAAA,EACAc,aAAc,EACf,EACKC,EAAe,CACnBC,KAAMC,EAAKC,cAEXC,WAAY,CAACP,CAAa,GAGtBQ,EAAkB,CACtBJ,KAAMC,EAAKI,SACXC,YAAa,CACXb,EACIc,EAAgCd,EAAeM,CAAY,EAC3DS,EAA+BtB,EAAkBa,CAAY,CAAC,GAItE,MAAO,CACLV,UAAW,MAAMoB,EAASC,EAAMN,CAAC,EAAGnB,CAAO,EAC3CK,MAAAA,EAEJ,GAEMI,EAAmBA,CAACf,EAAuBgC,IACvB,IAAIC,IAG1B,CACA,CAACjC,EAAOkC,aAAY,EAAI,OAAO,EAC/B,CAAClC,EAAOmC,gBAAe,EAAI,UAAU,EACrC,CAACnC,EAAOoC,oBAAmB,EAAI,cAAc,CAAC,CAC/C,EAEsBC,IAAIL,CAAI,EAI3BJ,EAAkCA,CACtCd,EACAM,KAEO,CACLC,KAAMC,EAAKgB,qBACXC,UAAWzB,EACXb,KAAMuC,OACNC,oBAAqB,CAAA,EACrBC,WAAY,CAAA,EACZtB,aAAAA,IAKES,EAAiCA,CACrC3B,EACAkB,KAEO,CACLC,KAAMC,EAAKqB,oBACX1C,KAAM,CACJoB,KAAMC,EAAKsB,KACXC,MAAO,QAETJ,oBAAqB,CAAA,EACrBC,WAAY,CAAA,EACZI,cAAe,CACbzB,KAAMC,EAAKyB,WACX9C,KAAM,CACJoB,KAAMC,EAAKsB,KACXC,MAAO3C,EAAWD,OAGtBmB,aAAAA,IAIS4B,GAAoBA,CAC/BhB,EACA,CAAE3B,SAAAA,EAAW,EAAGc,aAAAA,EAAe,CAAC,EAAK,CAAA,IACwB,CAC7D,IAAI8B,EAA2B,CAAA,EACzB7B,EAAiC,CACrCC,KAAMC,EAAKC,cACXC,WAAY,CAAA,GAGd,GAAI,CAACQ,EACH,MAAO,CAAEZ,aAAAA,EAAcT,MAAOsC,CAAQ,EAExC,IAAMC,EAAYC,EAAanB,CAAI,EAEnC,GACE,EACEkB,aAAqBzC,GACrByC,aAAqBE,GAGvB,MAAO,CAAEhC,aAAAA,EAAcT,MAAOsC,CAAQ,EAGxC,GAAII,EAAWrB,CAAI,EACjB,MAAO,CAAEZ,aAAAA,EAAcT,MAAOsC,CAAQ,EAGxC,GAAI9B,GAAgBd,EAClB,MAAO,CAAEe,aAAAA,EAAcT,MAAOsC,CAAQ,EAGxC,IAAMK,EAASJ,GAAaA,EAAUrC,UAAS,EAC/CO,OAAAA,EAAaI,WAAa+B,OAAOC,QAAQF,CAAM,EAAEG,IAAI,CAAC,CAAA,CAAG7C,CAAK,IAAK,CACjE,GAAM,CAAEI,KAAAA,EAAML,MAAAA,CAAK,EAAKO,EAAmBN,EAAO,CAChDP,SAAAA,EACAc,aAAAA,EACD,EAED8B,OAAAA,EAAW,CAAC,GAAGA,EAAU,GAAGtC,CAAK,EAE1BK,CACT,CAAC,EAEM,CAAEI,aAAAA,EAAcT,MAAOsC,CAAQ,CACxC,EAEa/B,EAAqBA,CAChCN,EACA,CAAEP,SAAAA,EAAW,EAAGc,aAAAA,EAAe,CAAC,EAAK,CAAA,IACnC,CACF,IAAMuC,EAAiC9C,EAAM+C,KAAKF,IAAKG,IAC9C,CACLvC,KAAMC,EAAKuC,SACX5D,KAAM,CACJoB,KAAMC,EAAKsB,KACXC,MAAOe,EAAI3D,MAEb4C,MAAOiB,EAA8BF,EAAI5B,KAAM4B,EAAIG,YAAY,GAElE,EAEK,CAAE3C,aAAAA,EAAcT,MAAAA,CAAK,EAAKqC,GAAkBpC,EAAMoB,KAAM,CAC5D3B,SAAAA,EACAc,aAAcA,EAAe,EAC9B,EAcD,MAAO,CAAEH,KAZI,CACXK,KAAMC,EAAK0C,MACXC,MAAOzB,OACPvC,KAAM,CACJoB,KAAMC,EAAKsB,KACXC,MAAOjC,EAAMX,MAEfiE,UAAWR,EACXhB,WAAY,CAAA,EACZtB,aAAAA,GAGaT,MAAO,CAAC,CAAEwD,QAAS,CAAC,CAACT,EAAeU,MAAM,EAAI,GAAGzD,CAAK,CAAC,CACxE,EAGMmD,EAAgCA,CACpCO,EACAN,EACA,CAAE5C,aAAAA,EAAe,EAAGd,SAAAA,EAAW,CAAC,EAAK,CAAA,IAGnCiE,EAAmCD,EAAcN,EAAc,CAC7D5C,aAAAA,EACAd,SAAAA,EACD,GAAK,CAAEgB,KAAMC,EAAKiD,OAAQ1B,MAAO,OAAO,EAGvCyB,EAAqCA,CACzCtC,EACA+B,EACA,CAAE5C,aAAAA,EAAe,EAAGd,SAAAA,EAAW,CAAC,EAAK,CAAA,IACL,CAChC,IAAMmE,EAAmBC,EAAaV,EAAc/B,CAAI,EACxD,GAAIwC,EACF,OAAOA,EAQT,GALIE,EAAc1C,CAAI,IACpBA,EAAOA,EAAK2C,QAIVC,EAAW5C,CAAI,EAUjB,MATyB,CACvBX,KAAMC,EAAKuD,KACXC,OAAQ,CACNhB,EAA8B9B,EAAK2C,OAAQnC,OAAW,CACpDrB,aAAcA,EAAe,EAC7Bd,SAAAA,EACD,CAAC,GAOR,GAAI0E,EAAa/C,CAAI,GAAKgD,EAAkBhD,CAAI,EAAG,CACjD,GAAIb,GAAgBd,EAClB,OAGF,IAAM4E,EAAgC,CAAA,EACtC,QAAWrE,KAAS2C,OAAOuB,OACxB9C,EAAgCnB,UAAS,CAAE,EAE5C,GAAIqE,EAAqBtE,CAAK,EAAG,CAC/B,IAAMuE,EAAab,EACjB1D,EAAMoB,KACNQ,OACA,CAAErB,aAAcA,EAAe,EAAGd,SAAAA,CAAQ,CAAE,EAE1C8E,GACFF,EAAWG,KAAK,CACd/D,KAAMC,EAAK+D,aACXpF,KAAM,CAAEoB,KAAMC,EAAKsB,KAAMC,MAAOjC,EAAMX,IAAI,EAC1C4C,MAAOsC,EACR,CAEL,CAEF,MAAO,CAAE9D,KAAMC,EAAKgE,OAAQhC,OAAQ2B,CAAU,CAChD,CAEA,GAAIjD,aAAgBuD,EAAiB,CACnC,IAAMxB,EAAe/B,EAAKwD,UAAS,EAAG,CAAC,EAEvC,OAAKzB,EAIEU,EAAaV,EAAa9D,KAAM+B,CAAI,EAHzC,MAIJ,CAIA,OAFiByD,EAAYzD,CAAI,EAEjB,CACd,IAAK,SACH,OAAOyC,EAAa,SAAUiB,CAAa,EAE7C,IAAK,UACH,OAAOjB,EAAa,GAAMkB,CAAc,EAE1C,IAAK,MACH,OAAOlB,EAAa,EAAGmB,CAAU,CAErC,CACF,EGnTA,IAAAC,GAAgBC,GACP,CACLA,EAAOC,aAAY,EACnBD,EAAOE,gBAAe,EACtBF,EAAOG,oBAAmB,CAAE,EAC5BC,OAAOC,OAAO","debug_id":"234234e3-c6bd-58b9-8ed9-c09889974842"}